[{"title":"http vs websocket","date":"2023-08-27T13:22:45.000Z","path":"2023/08/27/ websocket/","text":"通信串行通信中，数据通常是在俩个终端之间进行传送，根据数据流的传输方向分为以下三种基本传送方式：单工、半双工和全双工。 基本区别为： 单工：单工通信只有一根数据线，通信只在一个方向上进行，这种方式的应用实例有：监视器、打印机、电视机等。 半双工：半双工通信也只有一根数据线，它也单工的区别是这根数据线既可作发送又可作发接收，虽然数据可在两个方向上传送，但通信双方不能同时收发数据。http协议采用的就是这个通信方式 全双工： 数据的发送和接收用两根不同的数据线，通信双方在同一时刻都能进行发送和接收，这一工作方式称为全双工通信。在这种方式下，通信双方都有发送器和接收器，发送和接收可同时进行，没有时间延迟。websocket采用的就是这个通信方式 http http协议主要关注的是 客户端——&gt;服务器（获取资源） 特点：无状态协议； 每个请求都是独立的； 请求应答模式，服务器无法主动给客户端推送消息（单工，半双工，全双工） http受浏览器同源策略的影响 websocket双向通信（全双工协议）每次不需要重新建立连接，可以一直相互通信 不使用websocket 以前的双向通信的实现方式Comet，主要是为了是实现服务端可以像客户端桶送数据，为了继绝实时性比较高的情况。 1.轮询（客户端定期向服务端发送请求采用方式，前端setInterval定时器发送请求）轮询会在的问题： 轮询方式会存在竞速问题，无法保证请求的先后顺序，可能会存在多个请求返回的结果同时修改资源。 频繁的网络请求 会导致服务器负荷增加 同时频繁的客户端发请求也会影响客户端性能问题 http 发送的时候 会增加http报文（headers、鉴权、内容类型） 会出现额外的数据消耗 实时性比较低 定时轮询前端定时轮询（定时器发请求）无法处理即时处理的请求轮询的优点 容易实现 不适合实时性比较高的，低并发 2.长轮询（前端接口递归调用） 想解决短轮询的缺点（想将实时性更强）长轮询存在的问题 实时性强了，同时也造成了更多的网络请求 链接堆积问题，链接需要在服务端中保持打开，占有服务器资源（前端需要大量数据从服务端访问，会一直从服务端获取）优点 实时性强了，但是要求服务端的并发能力要强 3.iframe流（使用ifream存在的沙箱模式）存在的问题 单通信（服务端直接推送客户端消息）优点 具有实时性，且不需要客户端和服务端频繁发请求 4.sse EventSource（html提供的，单项通信，客户端可以监控服务端推送的事件。只能推送文本消息，适合小数据）123456789101112131415161718192021222324// 服务端代码 app.get('/clock',function(res,req){ // 这里表明服务器传递的是时间流 res.setHeader('Content-Type','text/event-stream'); setInterval(()=&gt;{ // 和http协议一样，按照行的方式传输 // Content-Type:xxx // Authorization:xxx res.write(`data:hello\\n\\n`) },1000) }) // 客户端代码 script中const eventsource = new EventSource('xxx接口地址')eventsource.onopen = function(){ console.log('Connection opened');}// 发送消息eventsource.onmessage = function(e){ console.log(e.data)}存在的问题- 单项传输，客户端无法给服务端传递数据 5.webSocket（h5提供的api）优点 双向通信 持久连接 发送的消息增加帧是非常小的 支持多种数据格式 天生支持跨域 1234567891011121314151617181920212223242526272829303132333435// 客户端代码const ws = new Websocket('ws://loacalhost:3000')ws.onopen = function(){ console.log('Content opened') ws.send('hello Serve')}ws.onmessage = function(e){ console.log('服务器响应数据：'+ e.data)}// 服务端代码import express from 'express'import http from 'http'// webSocket首先基于http协议import { WebSocket } from 'ws'const wsServer = new WebSocket({ server })wsServer.on('connection',(ws)=&gt;{ console.log('Connection opend') // 给客户端发送消息 ws.send('hellow client') ws.on('message',(message)=&gt;{ console.log('客户端发送的数据：' + message) })})server.listen(3000) 拓展: 协议的表示方式？ 以http为例子就是要了解http各种header的使用怎么实现握手的，数据长什么样子，怎么通信 查看网络得知：webSocket协议 请求行显示：请求方式 GET ws://localhost:3000 协议版本 HTTP/1.1 Connection : Upgrade Upgrade: websocket 升级的协议是什么 Sec-Websocket-Version: 13 协议的版本 生成Sec-Websocket-Key:用于生成唯一的，保证安全的websocket连接 防止恶意连接 可以用于握手 Sec-Websocket-Accept 是根据key算出来的 表示握手成功 通过wireshark工具可以抓包，了解会生成key-&gt;·GBUN9IA5TYXPYgQehlxEUw== 握手的时候创建一个随机的keyaccept-&gt; TpUkC2LowejLbA6ZRgwSL8Rk4FI= 服务端要响应一个值 每一次的key都不一样，采用以下方法创建安全的握手连接 1234567// 加密库import crypto from 'crypto'const number = '258EAFA5-E914-47DA-95CA-C5ABODC85B11const'; const websocketKey ='GBIN9IA5TYXPYgQehlxEUw=='// 采用hah算法生成更新生成摘要输出base64格式 响应给客户端const websocketAccept = crypto.createHash( 'sha1' ).update(websocketKey + number).digest( 'base64' ) 完整的握手过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 服务端代码import net from 'net'// 可以接受原始的消息// 每个人连接都会产生一个socketconst server = net.createServer(function(socket){ // 客户端发消息 先握手 socket.once('data',function(data){ // 发送的报文 data /** * data包含 GET / HTIP/1.1 *请求行* Host: localhost:3000 Connection: UpgradePragma: no-cacheCache Control: no-cacheUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac 0S X 10 15 7) AppleWebKit/537.36 (KHTMLlike Gecko) Chrome/115.0.0.0 Safari/537.36Upgrade: websocket 0rigin: http://127.0.0.1:5500 Sec WebSocket-Version: 13 Accept-Encoding: gzip,deflate,brAccept-Language: zh-CN, zh;g=0.9Sec-WebSocket-Key: LFD4X3DrVLhObMnKL0b5K0 Sec-WebSocket-Extensions: permessage-deflate; client max window bits */ data = data.toString() // 说明要升级成websocket协议 再报文中读取是否已经是websocket协议 if(data.match(/Upgrade:websocket/)){ /** * 在抓包工具中读取到 key用来解析 ***在报文中都是字符串存在的*** Host; localhost:3000\\r\\n Connection: Upgrade rn Pragma: no-cache rin Cache Control: nocache\\rin User-Agent; Mozilla/5.0 (Macintosh; Intel Mac 05 X 10 15 7) AppleWebkit/537,36 (KHTML, like Gecko Upgrade: websocket r\\n 0rigin: http://127.0.0.1:5500\\r\\n Sec-WebSocket-Version: 13r'nAccept-Encoding: gzip, deflate, bririnAccept-Language: zh-CN zh;a=0.9\\r\\n Sec-WebSocket-Key:P2P2F9kEf/wg18RkzXM8eA==\\rin Sec-WebSocket-Extensions: permessage-deflate; client max window bits'rinrin */ let rows = data.split('\\r\\n') console.log(rows) /** * rows 打印得出 GETHTTP/1.1Host: localhost:3000'Connection: Uggrade'Pragma; no-cache'Cache-Control; no-cache'\"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac 0S X 10 15 7) AppleWebKit/537.36 (KHTML，like Gecko) Chrome/115.0.0.0 Safari/537.36''Uparade: websocket' */ } })})server.listen(3000,function(){ console.log('server start port 3000')})","tags":[]},{"title":"webpack、vite的自动导包的\"爱恨情仇\"","date":"2022-10-19T13:21:48.000Z","path":"2022/10/19/ webpack、vite的自动导包的-爱恨情仇/","text":"webpack、vite的自动导包的”爱恨情仇”前言最近在开发Vue3+Vite的统一基座工程，遇到了模块自动导入的不同构建工具的引入方式，特此记录。 在项目中，为了避免频繁导入。大家都会在对应，例如项目使用Webpack 打包工具的。在其项目store文件下其中的index.js 文件中使用webpack提供的apirequire.context的方法实现自动导入。 ES 模块规范在实现自动导入模块前，我们先了解下ES 模块规范。 所谓的ES模块规范,即 JavaScript 的标准模块系统，它允许您使用 import 和 export 关键字来导入和导出模块。这是现代 JavaScript 中推荐使用的模块化方式。 在ES模块规范中，提供了import.meta.glob功能。它允许在项目运行中动态匹配特定模式的模块。例如以下代码就可以动态匹配到module模块下的所有js文件。 1import.meta.glob('./module/*.js') 话不多说，上干货例如，你的项目sotre文件目录为 12345678- store - module - module1.js - module2.js - ... - moduleN.js - main.js 其中module下的moduleX文件你的main.js为你的sotre入口文件， webpack中的自动导入的实现方式在main.js入口文件中你可以使用webpack提供require.context的方法实现module文件目录下的模块自动导入。 1234567const files = require.context('./model', false, /\\.js$/)const modules = {}files.keys().forEach((key) =&gt; { modules[key.replace(/(\\.\\/|\\.js)/g, '')] = files(key).default})export default modules 其中files.keys()是require.context方法返回的一个函数，它会返回一个包含所有匹配模块路径的数组。 require.context是Webpack提供的一个方法，它允许你在构建时动态地导入模块。该方法接收三个参数： directory: 表示要搜索的目录路径。 useSubdirectories: 表示是否搜索子目录。 regExp: 表示匹配文件的正则表达式。 在上面代码中，files就是通过require.context动态导入了./model目录下所有的.js文件，并使用正则表达式/\\.js$/来匹配文件。这样，files.keys()返回一个包含所有匹配模块路径的数组。例如控制台打印files.keys()可获得以下数组 123456[ \"./module1.js\", \"./module2.js\", \"./。。。.js\", \"./moduleN.js\"] 接着，我们可以使用.forEach()遍历这个数组，对每个匹配的模块进行处理，提取模块名，并将模块添加到modules对象中。这样，你就得到了一个以模块名为键、模块对象为值的modules对象，它包含了所有从./model目录中动态导入的模块。 vite自动导入的实现方式在main.js入口文件中你可以使用ES模块规范提供的import.meta.glob方法来获取特定模块的匹配模式，来实现自动导入。 12345678910111213141516171819// main.jsconst modules = {};async function importAllModules() { const files = import.meta.glob('./module/*.js'); for (const path in files) { const key = path.replace(/\\.\\/module\\/|\\.js/g, ''); const module = await files[path](); modules[key] = module.default; }}importAllModules().then(() =&gt; { console.log(modules); // 所有模块已导入并组合成对象});// 现在可以导出组合后的 modules 对象供其他地方使用export default modules; 在这种情况下，使用异步操作是因为模块导入是一个异步操作。import.meta.glob()方法会返回一个对象，该对象的键是匹配到的文件路径，值是一个函数，调用该函数将异步导入对应的模块。因此，我们需要使用异步操作来等待模块导入完成，然后再将其添加到modules对象中。 如果我们不使用异步操作，而是直接将模块导入的结果添加到module对象中，那么由于模块导入是异步的，modules对象可能在模块导入完成之前被导出，导致modules对象不完整或为空。使用异步操作可以确保在所有模块导入完成后再导出modules对象，保证其包含所有模块导出的内容。 总结为什么都是打包工具，会有不同的自动导入方式呢？在使用 Webpack 的情况下，与使用 Vite 或其他原生支持 ES 模块的项目相比，自动导入模块的实现会有一些区别。主要区别在于 Webpack 不支持 import.meta.glob，因为它是 ES 模块的一个特殊功能，而 Webpack 是一个打包工具，不完全符合 ES 模块的规范。 那这里就浅浅对比下俩种打包工具的差异吧webpack 成熟度高。Webpack是一个成熟且应用相当广泛的打包构建工具，具有强大的生态系统和社区支持。 打包速度较慢。Webpack打包速度在大型项目打包速度比较慢，从入口文件开始，基于代码中的import、export、require构建依赖树，将所有的模块打包到一个或者几个少数文件中。因此，项目规模庞大的话，启动和热更新更慢。每次代码变更构建都需要生成新的Bundle文件。 配置复杂。官网配置很多，需要处理不同的Loader和Plugin来管理不同的资源文件。 插件系统丰富。Webpack具有强大的插件系统，允许开发者根据需求扩展定义。 Tree Shaking。Webpack通过使用UglifyJS等工具进行Tree Shaking，消除未使用的代码 热模块替换（HMR）。Webpack支持热模块替换，但在某些情况下需要手动配置。 Vite 新兴技术。Vite是一个相较新的构建工具，旨在提供更快的开发体验和构建速度。 打包速度极快。Vite在开发环境下具有极快的启动和热更新速度，因为它采用了原生ES模块的方式，并且将依赖项保持为独立的文件，而不是打包到一个大文件中。 配置简单。Vite的配置比Webpack简单，尤其是对于常见的项目结构，大部分任务都无需额外配置。 热模块替换（HMR）。Vite对热模块替换的支持非常好，在开发过程中几乎不需要手动配置即可实现HMR。 Tree Shaking。Vite使用Rollup进行Tree Shaking，这使得未使用的代码更容易被消除。 插件系统还不够完善。Vite的插件系统仍在发展中，目前没有Webpack那么丰富的插件支持。 总之，Webpack更加适合与大型、复杂项目的构建工作，拥有成熟和完善的生态系统和社区。Vite更适合用于一些热更新快速的程序。","tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"https://ayozoo.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"vue3+vite环境变量踩雷","date":"2022-07-18T12:12:44.000Z","path":"2022/07/18/ vue3-vite环境变量踩雷/","text":"vue3 + vite 环境变量踩坑前言众所周知，项目搭建过程中，存在环境的区分。一般项目中都会存在env的俩个配置环境变量的配置文件。… 例如以下生产环境、开发环境的环境变量文件： 1234567891011121314//.env.development 生产环境变量文件# 开发环境配置ENV = 'development'# 开发环境VUE_APP_BASE_API = '/dev-api'// .env.production# 生产环境配置ENV = 'production'# 生产环境VUE_APP_BASE_API = '/web-api' 然后在package.json中配置对应环境启动命令用以启动不同环境 1234\"scripts\": { \"dev\": \"vue-cli-service --mode development\", \"build\": \"vue-cli-service build --mode production\", }, 什么是环境变量？根据代码运行环境变化而变化的变量就是所谓的环境变量。 在生产环境和开发环境中最多用以区分接口公共BASE_URL_API路径来请求不同接口。 环境变量一般在全局可以访问得到。在vue项目中，常见的环境变量访问方式是以下方式进行获取的： 12345// webpack.config.jsmodule.exports = { mode: process.env.NODE_ENV === 'production' ? 'production' : 'development'} 其中的process.env.NODE_ENV就是环境变量，他是Node.js提供的API，用以返回获取当前Shall(操作系统和运行环境)所有的环境变量。 vue2+webPack 与 vue3+vite项目搭建获取环境变量的区别：webpack、vite相似之处配置都是按照前言所述，创建对应的环境变量的env文件，配置package.json文件中对应环境的启动命令。 webpack中的环境变量在vue2项目中，webpack做了处理，使得浏览器可以直接识别获取到node环境的process.env变量。 创建方式：配置在项目中env环境变量配置文件中，webpack环境变量可随意命名 获取方式：可以通过***process.env***获取 所以在页面中可以获取相应的环境变量： 123//这里就是获取启动或者打包的命令获取对应的配置文件中的变量 console.log('当前环境是:',process.env.NODE_ENV) vite中的环境变量 创建方式：vite中环境创建存在俩种，都是在项目中env环境变量配置文件中配置： 创建以VITE_开头的环境变量 123456789# 开发环境配置NODE_ENV ='development'# 开发环境VITE_APP_BASE_API = '/dev-api'VITE_APP_URL = \"http://193.1.1.107:8042\"VITE_APP_BASE_PORT = \"80\" 更换VITE_前缀 以 envPrefix 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。参考官网： [共享配置]: https://vitejs.cn/vite3-cn/config/shared-options.html#envdir “VIte官方文档” 以 envPrefix 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。 类型： string | string[] 默认： VITE_ 安全注意事项 envPrefix 不应被设置为空字符串 ‘ ‘ ，这将暴露你所有的环境变量，导致敏感信息的意外泄漏。 检测到配置为 ‘ ‘ 时 Vite 将会抛出错误. 获取方式： Vite是在 import.meta.env对象上暴露当前Shall的环境变量。 以下是获取对象中常用的内在变量： 1234567891011// 应用运行的模式。import.meta.env.MODE: {string} // 部署应用时的基本 URL。他由base配置项决定。import. meta.env.BASE_URL: {string} // 应用是否运行在生产环境。import. meta.env.PROD: {boolean}// 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。import. meta.env.DEV: {boolean} // 应用是否运行在 import.meta.env.SSR: {boolean} server 上。 注意：以上的变量存在于运行环境中，对应的vite.config中获取不到。 在 Vite 的配置文件 vite.config.js 中，默认是不加载 .env 文件中的环境变量的。因为正常情况下，只有在评估完 Vite 配置之后，才知道哪些文件需要被加载，比如之前我们提到的root和envDir都会影响到加载的行为。不管如何，如果想要在配置中加载环境变量，可以使用 loadEnv 去加载环境变量。 1234567891011121314151617181920212223242526272829303132333435363738394041import { defineConfig, loadEnv } from \"vite\";import vue from \"@vitejs/plugin-vue\";import path from \"path\";// https://vitejs.dev/config/export default defineConfig(({ mode }) =&gt; { const env = loadEnv(mode, process.cwd(), \"\"); console.log(env.VITE_APP_BASE_API); const resolve = (dir) =&gt; path.resolve(__dirname, dir); return { base: \"./\", publicPath: resolve(\"./static\"), assetsPublicPath: \"./\", plugins: [vue()], extensions: [\".js\", \".ts\", \".jsx\", \".tsx\", \".json\", \".vue\"], resolve: { alias: { \"@\": resolve(\"src\"), }, }, // 本地运行配置，及反向代理配置 server: { host: \"127.0.0.1\", port: 80, open: false, strictPort: false, https: false, cors: true, proxy: { // 代理规则直接放在 server 对象下，而非嵌套的 server 对象中 [env.VITE_APP_BASE_API]: { target: \"http://172.1.1.210:8080\", changeOrigin: true, rewrite: (path) =&gt; path.replace(new RegExp(\"^\" + env.VITE_APP_BASE_API), \"/web-api\"), // 替换 /dev-api 为 target 接口地址 }, }, }, };}); 注意，mode必须解构后传入loadEnv mode变量中","tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"https://ayozoo.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"React入门","date":"2022-07-12T15:50:22.000Z","path":"2022/07/12/ React入门/","text":"ReactReact应用就是被组件的独立UI片段构建，React组件本质就是可以添加任意标签的JavaScript函数。 React组件的基本要素 基本的组件js文件存在要素：1、可以return出存在任意标签的JavaScript函数2、函数中需要存在return()Html结构3、最终需要将渲染的组件export出去 1234567891011121314151617181920function Profile() { return ( &lt;img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" /&gt; );}export default function Gallery() { return ( &lt;section&gt; &lt;h1&gt;Amazing scientists&lt;/h1&gt; &lt;Profile /&gt; &lt;Profile /&gt; &lt;Profile /&gt; &lt;/section&gt; );} React 组件导入导出 组件导入导出 语法 导出语句 导入语句 默认 export default function Button() {} import Button from ‘./Button.js’; 具名 export function Button() {} import { Button } from ‘./Button.js’ 组件导入导出1、Gallery.js1. 定义了Profile组件2. 该组件采用默认导出（export default function）2、app.js1. 使用默认导入，导入Gallery文件的组件Gallery2. 使用默认导出方式将app组件导出 1234567891011121314151617181920212223242526272829303132## app.jsimport Gallery from './Gallery.js';export default function App() { return ( &lt;Gallery /&gt; );}## Gallery.jsfunction Profile() { return ( &lt;img src=\"https://i.imgur.com/QIrZWGIs.jpg\" alt=\"Alan L. Hart\" /&gt; );}export default function Gallery() { return ( &lt;section&gt; &lt;h1&gt;了不起的科学家们&lt;/h1&gt; &lt;Profile /&gt; &lt;Profile /&gt; &lt;Profile /&gt; &lt;/section&gt; );} JSX书写标签语言什么是JSXJSX 是 JavaScript 语法扩展，可以让在 JavaScript 文件中书写类似 HTML 的标签。JSX 看起来和 HTML 很像，但它的语法更加严格并且可以动态展示信息。 为什么出现JSX随着Web交互性越来越强，逻辑开始决定页面的内容。也就是可以说JavaScript负责HTML内容。因此，在React中，渲染逻辑和标签存在同一个组件文件中。 使用JSX的优势例如将一个按钮的渲染逻辑和标签放在一起，可以确保他们在编辑的时候保持同步。反之，也可以说彼此无关的细节是隔离的。 JSX与HTML的区别每个 React 组件都是一个 JavaScript 函数，它会返回一些标签，React 会将这些标签渲染到浏览器上。React 组件使用一种被称为 JSX 的语法扩展来描述这些标签。JSX对于HTML来说，语法更加严格并且可以动态的展示信息。 ***JSX and React 是相互独立的东西。通常配合使用，也可以单独使用它们中的任意一个，JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库。 *** HTML转换为JSX现在存在一个html标签 1234567891011&lt;h1&gt;海蒂·拉玛的待办事项&lt;/h1&gt;&lt;img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" class=\"photo\"&gt;&lt;ul&gt; &lt;li&gt;发明一种新式交通信号灯 &lt;li&gt;排练一个电影场景 &lt;li&gt;改进频谱技术&lt;/ul&gt; 此时需要将它转化为React组件，可以这么做，是的没错。 采用 *** &lt;&gt; 或者其他标签*** 包裹。 123456789101112131415export default function TodoList() { return ( &lt;&gt; &lt;h1&gt;海蒂·拉玛的待办事项&lt;/h1&gt; &lt;img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" className=\"photo\" /&gt; &lt;ul&gt; &lt;li&gt;发明一种新式交通信号灯&lt;/li&gt; &lt;li&gt;排练一个电影场景&lt;/li&gt; &lt;li&gt;改进频谱技术&lt;/li&gt; &lt;/ul&gt; &lt;/&gt; JSX语法规则 只能返回一个根元素 就是return（）中必须只有一个根元素 不想在标签中增加一个额外的 ，可以用 &lt;&gt; 和 &lt;/&gt; 元素来代替 ***JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。 *** 标签必须闭合 使用驼峰式命名法给大部分属性命名！ JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。 JSX中通过大括号使用javaScriptJSX可以在JavaScript中编写类似HTML的标签，保证渲染逻辑和内容绑定。在需要在标签中添加Js逻辑或者引用标签的动态属性的时候可以在JSX的大括号里面编写Js。 JSX使用引号字符串 当你想将字符串属性传递给JSX时，放在单引号或者双引号中 当你想动态传值时，可以使用{ 和 } 替代 “ 和 “ 123456789101112131415161718192021222324// 字符串export default function Avatar() { return ( &lt;img className=\"avatar\" src=\"https://i.imgur.com/7vQD0fPs.jpg\" alt=\"Gregorio Y. Zara\" /&gt; );}// 变量export default function Avatar() { const avatar = 'https://i.imgur.com/7vQD0fPs.jpg'; const description = 'Gregorio Y. Zara'; return ( &lt;img className=\"avatar\" src={avatar} alt={description} /&gt; );} 注意:当使用src={ } 这种写法会去读取花括号中js中这个变量的值。 标签插值 JSX中允许在标签中插入大括号{}中使用变量 JSX中允许在标签中插入大括号{}中使用函数表达式 1234567891011121314151617181920212223// 变量export default function TodoList() { const name = 'Gregorio Y. Zara'; return ( &lt;h1&gt;{name}'s To Do List&lt;/h1&gt; );}// 函数表达式const today = new Date();function formatDate(date) { return new Intl.DateTimeFormat( 'zh-CN', { weekday: 'long' } ).format(date);}export default function TodoList() { return ( &lt;h1&gt;To Do List for {formatDate(today)}&lt;/h1&gt; );} 大括号的使用场景主要场景是字符串、数字、变量、和js表达式。 用作JSX标签*内部的文本*：&lt;h1&gt;{name}'s To Do List&lt;/h1&gt; 标签***=*后面紧跟的属性**：src={avatar} 会读取 avatar 变量，但是！！！对于src=\"{avatar}\"只会传一个字符串{avatar} 双大括号的使用场景双大括号其实是{}传递对象的传递方式。 对象也用大括号表示，例如 { name: \"Hedy Lamarr\", inventions: 5 }。因此，为了能在 JSX 中传递，必须用另一对额外的大括号包裹对象：person={{ name: \"Hedy Lamarr\", inventions: 5 }}。 也可使用嵌套对象，在jsx大括号中使用。 注意：内联 style 属性 使用驼峰命名法编写。例如，HTML &lt;ul style=\"background-color: black\"&gt; 在你的组件里应该写成 &lt;ul style={{ backgroundColor: 'black' }}&gt;。 12345678910111213141516171819202122232425262728293031323334353637383940// 对象传递export default function TodoList() { return ( &lt;ul style={{ backgroundColor: 'black', color: 'pink' }}&gt; &lt;li&gt;Improve the videophone&lt;/li&gt; &lt;li&gt;Prepare aeronautics lectures&lt;/li&gt; &lt;li&gt;Work on the alcohol-fuelled engine&lt;/li&gt; &lt;/ul&gt; );}// 嵌套对象传递const person = { name: 'Gregorio Y. Zara', theme: { backgroundColor: 'black', color: 'pink' }};export default function TodoList() { return ( &lt;div style={person.theme}&gt; &lt;h1&gt;{person.name}'s Todos&lt;/h1&gt; &lt;img className=\"avatar\" src=\"https://i.imgur.com/7vQD0fPs.jpg\" alt=\"Gregorio Y. Zara\" /&gt; &lt;ul&gt; &lt;li&gt;Improve the videophone&lt;/li&gt; &lt;li&gt;Prepare aeronautics lectures&lt;/li&gt; &lt;li&gt;Work on the alcohol-fuelled engine&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );} Props组件传递React组件使用Props互相通信。每个父组件都可以提供props给他的自组件传递信息。可以通过Props传递认识JavaScript值，包括对象、数组、和函数。 Props传递类似HTML预定义的属性。像组件传递的时候可以传递任意的props。传递的props可以通过不同的方式进行渲染。 123456789101112131415161718192021222324// 其中person就是props/* 其中的花括号也就是props传递对象而已*/// 1、传递export default function Profile() { return ( &lt;Avatar person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }} size={100} /&gt; );}// 2、使用/读取/* 1.以下这种方式是采用解构，将person的props解构为单独的props传递 2.prop可以存在默认值，例如下面的prop size*/function Avatar({ person, size=100 }) { // 在这里 person 和 size 是可访问的} Props的使用，必须要关注你的父子组件。需要考虑好父组件需要向自组件传的props，而子组件需要考虑传递的props通过什么方式去进行渲染。事实上，**就可以总结出来,React函数组件就是接受一个参数，那就是Props对象。** Props使用妙计 prop可以指定默认值 如果渲染时不存在size的prop，那么size将被赋值100进行渲染 其实就是size的prop属性不存在或者值undefined时会生效 但是，如果传递size={null} 或 size={0}，默认值将 不 被使用。 123function Avatar({ person, size = 100 }) { // ...} 可以使用JSX展开语法传递Props 会存在需要传递pros很多，需要声明prop传递 1234567891011function Profile({ person, size, isSepia, thickBorder }) { return ( &lt;div className=\"card\"&gt; &lt;Avatar person={person} size={size} isSepia={isSepia} thickBorder={thickBorder} /&gt; &lt;/div&gt; ); 如果存在将所有的props传递给子组件可以采用简洁展开语法，这种写法，将父组件需要传递的props全部传递。如果滥用，那么建议拆分组件。 1234567function Profile(props) { return ( &lt;div className=\"card\"&gt; &lt;Avatar {...props} /&gt; &lt;/div&gt; );} 将JSX作为子组件传递 类似HTML标签嵌套，以下例子在父组件card中将children组件作为prop传递，类似vue插槽 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// app.jsimport Avatar from './Avatar.js';function Card({ children }) { return ( &lt;div className=\"card\"&gt; {children} &lt;/div&gt; );}export default function Profile() { return ( &lt;Card&gt; &lt;Avatar size={100} person={{ name: 'Katsuko Saruhashi', imageId: 'YfeOqp2' }} /&gt; &lt;/Card&gt; );}// Avatar.jsimport { getImageUrl } from './utils.js';export default function Avatar({ person, size }) { return ( &lt;img className=\"avatar\" src={getImageUrl(person)} alt={person.name} width={size} height={size} /&gt; );}// utils.jsexport function getImageUrl(person, size = 's') { return ( 'https://i.imgur.com/' + person.imageId + size + '.jpg' );} 注意一个组件可能会随着时间的推移收到不同的 props。 Props 并不总是静态的！Props 反映了组件在任何时间点的数据，并不仅仅是在开始时。 然而，props 是 不可变的（一个计算机科学术语，意思是“不可改变”）。当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 不同的 props —— 一个新对象！它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。不要尝试“更改 props”。","tags":[]}]