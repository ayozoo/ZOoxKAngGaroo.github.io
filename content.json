[{"title":"http vs websocket","date":"2023-08-27T13:22:45.000Z","path":"2023/08/27/ websocket/","text":"通信串行通信中，数据通常是在俩个终端之间进行传送，根据数据流的传输方向分为以下三种基本传送方式：单工、半双工和全双工。 基本区别为： 单工：单工通信只有一根数据线，通信只在一个方向上进行，这种方式的应用实例有：监视器、打印机、电视机等。 半双工：半双工通信也只有一根数据线，它也单工的区别是这根数据线既可作发送又可作发接收，虽然数据可在两个方向上传送，但通信双方不能同时收发数据。http协议采用的就是这个通信方式 全双工： 数据的发送和接收用两根不同的数据线，通信双方在同一时刻都能进行发送和接收，这一工作方式称为全双工通信。在这种方式下，通信双方都有发送器和接收器，发送和接收可同时进行，没有时间延迟。websocket采用的就是这个通信方式 http http协议主要关注的是 客户端——&gt;服务器（获取资源） 特点：无状态协议； 每个请求都是独立的； 请求应答模式，服务器无法主动给客户端推送消息（单工，半双工，全双工） http受浏览器同源策略的影响 websocket双向通信（全双工协议）每次不需要重新建立连接，可以一直相互通信 不使用websocket 以前的双向通信的实现方式Comet，主要是为了是实现服务端可以像客户端桶送数据，为了继绝实时性比较高的情况。 1.轮询（客户端定期向服务端发送请求采用方式）轮询会在的问题：轮询方式会存在竞速问题，无法保证请求的先后顺序，可能会存在多个请求返回的结果同时修改资源 2.长轮询 3.iframe流 4.sse EventSource（只能推送文本消息） 5.webSocket","tags":[]},{"title":"webpack、vite的自动导包的\"爱恨情仇\"","date":"2023-07-19T13:21:48.000Z","path":"2023/07/19/ webpack、vite的自动导包的-爱恨情仇/","text":"webpack、vite的自动导包的”爱恨情仇”前言最近在开发Vue3+Vite的统一基座工程，遇到了模块自动导入的不同构建工具的引入方式，特此记录。 在项目中，为了避免频繁导入。大家都会在对应，例如项目使用Webpack 打包工具的。在其项目store文件下其中的index.js 文件中使用webpack提供的apirequire.context的方法实现自动导入。 ES 模块规范在实现自动导入模块前，我们先了解下ES 模块规范。 所谓的ES模块规范,即 JavaScript 的标准模块系统，它允许您使用 import 和 export 关键字来导入和导出模块。这是现代 JavaScript 中推荐使用的模块化方式。 在ES模块规范中，提供了import.meta.glob功能。它允许在项目运行中动态匹配特定模式的模块。例如以下代码就可以动态匹配到module模块下的所有js文件。 1import.meta.glob('./module/*.js') 话不多说，上干货例如，你的项目sotre文件目录为 12345678- store - module - module1.js - module2.js - ... - moduleN.js - main.js 其中module下的moduleX文件你的main.js为你的sotre入口文件， webpack中的自动导入的实现方式在main.js入口文件中你可以使用webpack提供require.context的方法实现module文件目录下的模块自动导入。 1234567const files = require.context('./model', false, /\\.js$/)const modules = {}files.keys().forEach((key) =&gt; { modules[key.replace(/(\\.\\/|\\.js)/g, '')] = files(key).default})export default modules 其中files.keys()是require.context方法返回的一个函数，它会返回一个包含所有匹配模块路径的数组。 require.context是Webpack提供的一个方法，它允许你在构建时动态地导入模块。该方法接收三个参数： directory: 表示要搜索的目录路径。 useSubdirectories: 表示是否搜索子目录。 regExp: 表示匹配文件的正则表达式。 在上面代码中，files就是通过require.context动态导入了./model目录下所有的.js文件，并使用正则表达式/\\.js$/来匹配文件。这样，files.keys()返回一个包含所有匹配模块路径的数组。例如控制台打印files.keys()可获得以下数组 123456[ \"./module1.js\", \"./module2.js\", \"./。。。.js\", \"./moduleN.js\"] 接着，我们可以使用.forEach()遍历这个数组，对每个匹配的模块进行处理，提取模块名，并将模块添加到modules对象中。这样，你就得到了一个以模块名为键、模块对象为值的modules对象，它包含了所有从./model目录中动态导入的模块。 vite自动导入的实现方式在main.js入口文件中你可以使用ES模块规范提供的import.meta.glob方法来获取特定模块的匹配模式，来实现自动导入。 12345678910111213141516171819// main.jsconst modules = {};async function importAllModules() { const files = import.meta.glob('./module/*.js'); for (const path in files) { const key = path.replace(/\\.\\/module\\/|\\.js/g, ''); const module = await files[path](); modules[key] = module.default; }}importAllModules().then(() =&gt; { console.log(modules); // 所有模块已导入并组合成对象});// 现在可以导出组合后的 modules 对象供其他地方使用export default modules; 在这种情况下，使用异步操作是因为模块导入是一个异步操作。import.meta.glob()方法会返回一个对象，该对象的键是匹配到的文件路径，值是一个函数，调用该函数将异步导入对应的模块。因此，我们需要使用异步操作来等待模块导入完成，然后再将其添加到modules对象中。 如果我们不使用异步操作，而是直接将模块导入的结果添加到module对象中，那么由于模块导入是异步的，modules对象可能在模块导入完成之前被导出，导致modules对象不完整或为空。使用异步操作可以确保在所有模块导入完成后再导出modules对象，保证其包含所有模块导出的内容。 总结为什么都是打包工具，会有不同的自动导入方式呢？在使用 Webpack 的情况下，与使用 Vite 或其他原生支持 ES 模块的项目相比，自动导入模块的实现会有一些区别。主要区别在于 Webpack 不支持 import.meta.glob，因为它是 ES 模块的一个特殊功能，而 Webpack 是一个打包工具，不完全符合 ES 模块的规范。 那这里就浅浅对比下俩种打包工具的差异吧webpack 成熟度高。Webpack是一个成熟且应用相当广泛的打包构建工具，具有强大的生态系统和社区支持。 打包速度较慢。Webpack打包速度在大型项目打包速度比较慢，从入口文件开始，基于代码中的import、export、require构建依赖树，将所有的模块打包到一个或者几个少数文件中。因此，项目规模庞大的话，启动和热更新更慢。每次代码变更构建都需要生成新的Bundle文件。 配置复杂。官网配置很多，需要处理不同的Loader和Plugin来管理不同的资源文件。 插件系统丰富。Webpack具有强大的插件系统，允许开发者根据需求扩展定义。 Tree Shaking。Webpack通过使用UglifyJS等工具进行Tree Shaking，消除未使用的代码 热模块替换（HMR）。Webpack支持热模块替换，但在某些情况下需要手动配置。 Vite 新兴技术。Vite是一个相较新的构建工具，旨在提供更快的开发体验和构建速度。 打包速度极快。Vite在开发环境下具有极快的启动和热更新速度，因为它采用了原生ES模块的方式，并且将依赖项保持为独立的文件，而不是打包到一个大文件中。 配置简单。Vite的配置比Webpack简单，尤其是对于常见的项目结构，大部分任务都无需额外配置。 热模块替换（HMR）。Vite对热模块替换的支持非常好，在开发过程中几乎不需要手动配置即可实现HMR。 Tree Shaking。Vite使用Rollup进行Tree Shaking，这使得未使用的代码更容易被消除。 插件系统还不够完善。Vite的插件系统仍在发展中，目前没有Webpack那么丰富的插件支持。 总之，Webpack更加适合与大型、复杂项目的构建工作，拥有成熟和完善的生态系统和社区。Vite更适合用于一些热更新快速的程序。","tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"https://ayozoo.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"vue3+vite环境变量踩雷","date":"2023-07-18T12:12:44.000Z","path":"2023/07/18/ vue3-vite环境变量踩雷/","text":"vue3 + vite 环境变量踩坑前言众所周知，项目搭建过程中，存在环境的区分。一般项目中都会存在env的俩个配置环境变量的配置文件。… 例如以下生产环境、开发环境的环境变量文件： 1234567891011121314//.env.development 生产环境变量文件# 开发环境配置ENV = 'development'# 开发环境VUE_APP_BASE_API = '/dev-api'// .env.production# 生产环境配置ENV = 'production'# 生产环境VUE_APP_BASE_API = '/web-api' 然后在package.json中配置对应环境启动命令用以启动不同环境 1234\"scripts\": { \"dev\": \"vue-cli-service --mode development\", \"build\": \"vue-cli-service build --mode production\", }, 什么是环境变量？根据代码运行环境变化而变化的变量就是所谓的环境变量。 在生产环境和开发环境中最多用以区分接口公共BASE_URL_API路径来请求不同接口。 环境变量一般在全局可以访问得到。在vue项目中，常见的环境变量访问方式是以下方式进行获取的： 12345// webpack.config.jsmodule.exports = { mode: process.env.NODE_ENV === 'production' ? 'production' : 'development'} 其中的process.env.NODE_ENV就是环境变量，他是Node.js提供的API，用以返回获取当前Shall(操作系统和运行环境)所有的环境变量。 vue2+webPack 与 vue3+vite项目搭建获取环境变量的区别：webpack、vite相似之处配置都是按照前言所述，创建对应的环境变量的env文件，配置package.json文件中对应环境的启动命令。 webpack中的环境变量在vue2项目中，webpack做了处理，使得浏览器可以直接识别获取到node环境的process.env变量。 创建方式：配置在项目中env环境变量配置文件中，webpack环境变量可随意命名 获取方式：可以通过***process.env***获取 所以在页面中可以获取相应的环境变量： 123//这里就是获取启动或者打包的命令获取对应的配置文件中的变量 console.log('当前环境是:',process.env.NODE_ENV) vite中的环境变量 创建方式：vite中环境创建存在俩种，都是在项目中env环境变量配置文件中配置： 创建以VITE_开头的环境变量 123456789# 开发环境配置NODE_ENV ='development'# 开发环境VITE_APP_BASE_API = '/dev-api'VITE_APP_URL = \"http://193.1.1.107:8042\"VITE_APP_BASE_PORT = \"80\" 更换VITE_前缀 以 envPrefix 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。参考官网： [共享配置]: https://vitejs.cn/vite3-cn/config/shared-options.html#envdir “VIte官方文档” 以 envPrefix 开头的环境变量会通过 import.meta.env 暴露在你的客户端源码中。 类型： string | string[] 默认： VITE_ 安全注意事项 envPrefix 不应被设置为空字符串 ‘ ‘ ，这将暴露你所有的环境变量，导致敏感信息的意外泄漏。 检测到配置为 ‘ ‘ 时 Vite 将会抛出错误. 获取方式： Vite是在 import.meta.env对象上暴露当前Shall的环境变量。 以下是获取对象中常用的内在变量： 1234567891011// 应用运行的模式。import.meta.env.MODE: {string} // 部署应用时的基本 URL。他由base配置项决定。import. meta.env.BASE_URL: {string} // 应用是否运行在生产环境。import. meta.env.PROD: {boolean}// 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。import. meta.env.DEV: {boolean} // 应用是否运行在 import.meta.env.SSR: {boolean} server 上。 注意：以上的变量存在于运行环境中，对应的vite.config中获取不到。 在 Vite 的配置文件 vite.config.js 中，默认是不加载 .env 文件中的环境变量的。因为正常情况下，只有在评估完 Vite 配置之后，才知道哪些文件需要被加载，比如之前我们提到的root和envDir都会影响到加载的行为。不管如何，如果想要在配置中加载环境变量，可以使用 loadEnv 去加载环境变量。 1234567891011121314151617181920212223242526272829303132333435363738394041import { defineConfig, loadEnv } from \"vite\";import vue from \"@vitejs/plugin-vue\";import path from \"path\";// https://vitejs.dev/config/export default defineConfig(({ mode }) =&gt; { const env = loadEnv(mode, process.cwd(), \"\"); console.log(env.VITE_APP_BASE_API); const resolve = (dir) =&gt; path.resolve(__dirname, dir); return { base: \"./\", publicPath: resolve(\"./static\"), assetsPublicPath: \"./\", plugins: [vue()], extensions: [\".js\", \".ts\", \".jsx\", \".tsx\", \".json\", \".vue\"], resolve: { alias: { \"@\": resolve(\"src\"), }, }, // 本地运行配置，及反向代理配置 server: { host: \"127.0.0.1\", port: 80, open: false, strictPort: false, https: false, cors: true, proxy: { // 代理规则直接放在 server 对象下，而非嵌套的 server 对象中 [env.VITE_APP_BASE_API]: { target: \"http://172.1.1.210:8080\", changeOrigin: true, rewrite: (path) =&gt; path.replace(new RegExp(\"^\" + env.VITE_APP_BASE_API), \"/web-api\"), // 替换 /dev-api 为 target 接口地址 }, }, }, };}); 注意，mode必须解构后传入loadEnv mode变量中","tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"https://ayozoo.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"React入门","date":"2023-07-12T15:50:22.000Z","path":"2023/07/12/ React入门/","text":"你好我是React","tags":[]}]