<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/logo.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.svg">
  <link rel="mask-icon" href="/favicon/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ayozoo.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="React入门之添加交互界面上的控件对随着用户的输入而更新。例如点击按钮切换轮播图的展示。在React中，随着时间变化的数据称为状态（state）。可以向任何组件添加状态，按需去进行更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="React入门之添加交互">
<meta property="og:url" content="https://ayozoo.github.io/2023/11/02/%20React-%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92/index.html">
<meta property="og:site_name" content="ayozooZ">
<meta property="og:description" content="React入门之添加交互界面上的控件对随着用户的输入而更新。例如点击按钮切换轮播图的展示。在React中，随着时间变化的数据称为状态（state）。可以向任何组件添加状态，按需去进行更新。">
<meta property="og:locale">
<meta property="article:published_time" content="2023-11-02T15:21:22.000Z">
<meta property="article:modified_time" content="2023-11-08T15:31:43.168Z">
<meta property="article:author" content="ayozooZ">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ayozoo.github.io/2023/11/02/%20React-%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"https://ayozoo.github.io/2023/11/02/%20React-%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92/","path":"2023/11/02/ React-添加交互/","title":"React入门之添加交互"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>React入门之添加交互 | ayozooZ</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="ayozooZ" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ayozooZ</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">ayozooZ的blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">6</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92"><span class="nav-number">1.</span> <span class="nav-text">React入门之添加交互</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">响应事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是响应事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">事件处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">添加事件处理函数步骤：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">事件函数特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">事件处理函数传递的陷阱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%B8%AD%E8%AF%BB%E5%8F%96props"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">在事件处理函数中读取props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BAprops%E4%BC%A0%E9%80%92"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">将事件处理函数作为props传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0prop"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">命名事件处理函数prop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">事件传播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E4%BC%A0%E6%92%AD"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">阻止传播</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#onClickCapture%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.1.2.8.1.</span> <span class="nav-text">onClickCapture捕获所有事件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E7%9A%84%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">传递处理函数作为事件传播的代替方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.1.2.10.</span> <span class="nav-text">阻止默认行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%89%AF%E4%BD%9C%E7%94%A8%E5%90%97"><span class="nav-number">1.1.2.11.</span> <span class="nav-text">事件函数可以包含副作用吗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#state%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%B0%E5%BF%86"><span class="nav-number">1.2.</span> <span class="nav-text">state：组件的记忆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%B0%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">1.2.1.</span> <span class="nav-text">如何使用新数据更新组件?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%99%E6%97%B6%E5%80%99%E5%B0%B1%E5%BC%95%E5%87%BA%E4%BA%86%EF%BC%8C%E4%B8%BB%E4%BA%BA%E5%85%AC%EF%BC%9AuseStateHook%E3%80%82"><span class="nav-number">1.2.2.</span> <span class="nav-text">这时候就引出了，主人公：useStateHook。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%EF%BC%88%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAstate%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">使用姿势（如何添加一个state变量）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90useState"><span class="nav-number">1.2.3.</span> <span class="nav-text">深度剖析useState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88React%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E8%A6%81%E8%BF%94%E5%9B%9E%E5%93%AA%E4%B8%AAstate%EF%BC%9F%EF%BC%9F"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">拓展：为什么React如何知道要返回哪个state？？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#State%E6%98%AF%E9%9A%94%E7%A6%BB%E4%B8%94%E7%A7%81%E6%9C%89%E7%9A%84"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">State是隔离且私有的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8F%90%E4%BA%A4"><span class="nav-number">1.3.</span> <span class="nav-text">渲染和提交</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E8%A7%A6%E5%8F%91%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93"><span class="nav-number">1.3.1.</span> <span class="nav-text">步骤1：触发一次渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">初次渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E9%87%8D%E7%8E%B0%E6%B8%B2%E6%9F%93"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">状态更新时重现渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42-React%E6%B8%B2%E6%9F%93%E4%BD%A0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">步骤2:React渲染你的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.2.0.1.</span> <span class="nav-text">性能优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A43-React%E6%8A%8A%E6%9B%B4%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0DOM%E4%B8%8A"><span class="nav-number">1.3.3.</span> <span class="nav-text">步骤3:React把更改提交到DOM上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">浏览器绘制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#state%E5%A6%82%E5%90%8C%E4%B8%80%E5%BC%A0%E5%BF%AB%E7%85%A7"><span class="nav-number">1.4.</span> <span class="nav-text">state如同一张快照</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEstate%E4%BC%9A%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93"><span class="nav-number">1.4.1.</span> <span class="nav-text">设置state会触发渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E4%BC%9A%E5%8F%8A%E6%97%B6%E7%94%9F%E5%87%BA%E4%B8%80%E5%BC%A0%E5%BF%AB%E7%85%A7"><span class="nav-number">1.4.2.</span> <span class="nav-text">渲染会及时生出一张快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E7%9D%80%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84state"><span class="nav-number">1.4.3.</span> <span class="nav-text">随着时间变化的state</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E4%B8%80%E7%B3%BB%E5%88%97state%E6%9B%B4%E6%96%B0%E5%8A%A0%E5%85%A5%E9%98%9F%E5%88%97"><span class="nav-number">1.5.</span> <span class="nav-text">把一系列state更新加入队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React%E4%BC%9A%E5%AF%B9state%E6%9B%B4%E6%96%B0%E8%BF%9B%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-number">1.5.1.</span> <span class="nav-text">React会对state更新进行批处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%8B%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%89%8D%E8%AF%BB%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%90%8C%E4%B8%80%E4%B8%AAstate"><span class="nav-number">1.5.2.</span> <span class="nav-text">在下次渲染前读次更新同一个state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E6%9B%BF%E6%8D%A2state%E5%90%8E%E6%9B%B4%E6%96%B0state%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.3.</span> <span class="nav-text">如果在替换state后更新state会发生什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E6%9B%B4%E6%96%B0state%E5%90%8E%E6%9B%BF%E6%8D%A2state%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">1.5.4.</span> <span class="nav-text">如果在更新state后替换state会发生什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E6%83%AF%E4%BE%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">命名惯例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0state%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.</span> <span class="nav-text">更新state中的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmutation"><span class="nav-number">1.6.1.</span> <span class="nav-text">什么是mutation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state%E5%AD%98%E6%94%BE%E6%95%B0%E5%AD%97"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">state存放数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state%E5%AD%98%E6%94%BE%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">state存放对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86state%E8%A7%86%E4%B8%BA%E5%8F%AA%E8%AF%BB%E7%9A%84"><span class="nav-number">1.6.2.</span> <span class="nav-text">将state视为只读的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E7%9A%84mutation%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E7%9A%84"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">局部的mutation是可以接受的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.3.</span> <span class="nav-text">使用展开语法复制对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%9D%A5%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">使用一个事件处理函数来更新多个字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.4.</span> <span class="nav-text">更新一个嵌套对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%9D%9E%E6%98%AF%E5%B5%8C%E5%A5%97%E7%9A%84"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">对象并非是嵌套的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Immer%E7%BC%96%E5%86%99%E7%AE%80%E4%BB%8B%E7%9A%84%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91"><span class="nav-number">1.6.5.</span> <span class="nav-text">使用Immer编写简介的更新逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Immer-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">Immer 是如何运行的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Immer"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">如何使用Immer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0state%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.</span> <span class="nav-text">更新state中的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%B2%A1%E6%9C%89mutation%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.1.</span> <span class="nav-text">在没有mutation的前提下更新数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.2.</span> <span class="nav-text">向数组中添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.3.</span> <span class="nav-text">从数组中删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.4.</span> <span class="nav-text">转换数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.5.</span> <span class="nav-text">替换数组中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.6.</span> <span class="nav-text">向数组中插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E6%83%85%E5%86%B5"><span class="nav-number">1.7.7.</span> <span class="nav-text">其他改变数组情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.8.</span> <span class="nav-text">更新数组内部的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Immer%E7%BC%96%E5%86%99%E7%AE%80%E6%B4%81%E7%9A%84%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91"><span class="nav-number">1.7.9.</span> <span class="nav-text">使用Immer编写简洁的更新逻辑</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ayozooZ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ayozooZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ayozoo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ayozoo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Nikon_?type=blog" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Nikon_?type&#x3D;blog" rel="noopener me" target="_blank"><i class="fab fa-book fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/1869629711195757" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;1869629711195757" rel="noopener me" target="_blank"><i class="fab fa-chain-broken fa-fw"></i>掘金</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://ayozoo.github.io/2023/11/02/%20React-%E6%B7%BB%E5%8A%A0%E4%BA%A4%E4%BA%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ayozooZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ayozooZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="React入门之添加交互 | ayozooZ">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React入门之添加交互
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-02 23:21:22" itemprop="dateCreated datePublished" datetime="2023-11-02T23:21:22+08:00">2023-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-08 23:31:43" itemprop="dateModified" datetime="2023-11-08T23:31:43+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">前端框架</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>45 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><hr>
<h1 id="React入门之添加交互"><a href="#React入门之添加交互" class="headerlink" title="React入门之添加交互"></a>React入门之添加交互</h1><p>界面上的控件对随着用户的输入而更新。例如点击按钮切换轮播图的展示。在React中，随着时间变化的数据称为<strong>状态（state）</strong>。可以向任何组件添加状态，<strong>按需去进行更新</strong>。</p>
<span id="more"></span>


<h2 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h2><h3 id="什么是响应事件"><a href="#什么是响应事件" class="headerlink" title="什么是响应事件"></a>什么是响应事件</h3><p>React允许我们在JSX中添加时间处理程序。事件处理程序是我们自己定义的函数。比如我们界面交互时：点击、悬停、焦点聚焦等交互事件。</p>
<p>我们在自己的组件中可以定义我们自己的<strong>事件处理程序</strong>。<strong>做法是往我们的组件时间处理程序props指定特定应用的名称</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 定义button组件 通过props接收onclick事件</span><br><span class="line">// {children} 作为插槽接收</span><br><span class="line">function Button({ onClick, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={onClick}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义Toolbar 通过props接收onPlayMovie、onUploadImage事件</span><br><span class="line">// 这里的"Play Movie、 Upload Image" 作为子组件插入</span><br><span class="line">function Toolbar({ onPlayMovie, onUploadImage }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick={onPlayMovie}&gt;</span><br><span class="line">        Play Movie</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick={onUploadImage}&gt;</span><br><span class="line">        Upload Image</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 导出最终组件</span><br><span class="line">// 这里的onPlayMovie、onUploadImage就是对应Toolbar组件接收的事件处理程序、最终传入Button的onClick事件中</span><br><span class="line">export default function App() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;Toolbar</span><br><span class="line">      onPlayMovie={() =&gt; alert('Playing!')}</span><br><span class="line">      onUploadImage={() =&gt; alert('Uploading!')}</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h3><h4 id="添加事件处理函数步骤："><a href="#添加事件处理函数步骤：" class="headerlink" title="添加事件处理函数步骤："></a>添加事件处理函数步骤：</h4><ol>
<li>首先定义一个函数组件</li>
<li>在函数组件中定义事件处理程序的函数，然后<strong>将其作为prop传入</strong>合适的JSX标签。</li>
</ol>
<h4 id="事件函数特点："><a href="#事件函数特点：" class="headerlink" title="事件函数特点："></a>事件函数特点：</h4><ul>
<li><p>通常是在<strong>组件内部</strong>定义</p>
</li>
<li><p>名称<code>handle</code>开头，后面跟事件名称</p>
<p>事件处理函数可以在JSX中有俩种定义方式：</p>
<ul>
<li>内联事件处理函数（<em><strong>函数体比较短使用较为方便</strong></em>）</li>
<li>简洁函数</li>
</ul>
</li>
</ul>
<p>这时候看个例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default function Button() {</span><br><span class="line">  function handleClick() {</span><br><span class="line">    alert('你点击了我！');</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={handleClick}&gt;</span><br><span class="line">      点我</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 简洁箭头函数</span><br><span class="line">  &lt;button onClick={() =&gt; {</span><br><span class="line">  alert('你点击了我！');</span><br><span class="line">}}&gt;</span><br><span class="line">  </span><br><span class="line">// 内联写法</span><br><span class="line">&lt;button onClick={function handleClick() {</span><br><span class="line">  alert('你点击了我！');</span><br><span class="line">}}&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="事件处理函数传递的陷阱"><a href="#事件处理函数传递的陷阱" class="headerlink" title="事件处理函数传递的陷阱"></a>事件处理函数传递的陷阱</h4><p>在Vue中会出现事件绑定时，直接触发事件处理程序。在这里存在陷阱。</p>
<p>传递给事件处理函数的函数应直接传递，而非调用。看下面的例子：</p>
<table>
<thead>
<tr>
<th align="center"><strong>传递一个函数（正确）</strong></th>
<th align="center"><strong>调用一个函数（错误）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><button onclick="{handleClick}"></button></td>
<td align="center"><button onclick="{handleClick()}"></button></td>
</tr>
</tbody></table>
<p>这样看来其实，区别很微妙。</p>
<p>左侧示例中<code>handleClick</code>函数作为<code>onClick</code>的事件处理函数传递。这个是告诉React这个事件是当用户点击按钮时才会触发函数。</p>
<p>右侧示例中<code>handleClick()</code>中最后的<code>()</code>会在<strong>渲染过程中立即触发函数</strong>，即使没有任何点击。这是因为<strong>JSX<code>{</code>和<code>}</code>之间的Javascript会立即执行</strong>。</p>
<p>当传入内联函数时，会出现不同的陷阱。</p>
<table>
<thead>
<tr>
<th><strong>传递一个函数（正确）</strong></th>
<th><strong>调用一个函数（错误）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&lt;button onClick={() =&gt; alert(‘…’)}&gt;</td>
<td>&lt;button onClick={alert(‘…’)}&gt;</td>
</tr>
</tbody></table>
<p>右侧的写法，将会导致组件渲染时，每次都触发。</p>
<p>左侧就是创建了一个稍后调用的函数，而不是在每次渲染时执行其内部的代码。</p>
<p><strong>综上，就是想要定义内联函数事件处理函数，要将其包装在匿名函数中。</strong></p>
<h4 id="在事件处理函数中读取props"><a href="#在事件处理函数中读取props" class="headerlink" title="在事件处理函数中读取props"></a>在事件处理函数中读取props</h4><p>事件函数声明于组件内部，因此他们可以直接访问组件的props。</p>
<p>例如：事件处理函数就可以接收到message</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function AlertButton({ message, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={() =&gt; alert(message)}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default function Toolbar() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;AlertButton message="正在播放！"&gt;</span><br><span class="line">        播放电影</span><br><span class="line">      &lt;/AlertButton&gt;</span><br><span class="line">      &lt;AlertButton message="正在上传！"&gt;</span><br><span class="line">        上传图片</span><br><span class="line">      &lt;/AlertButton&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="将事件处理函数作为props传递"><a href="#将事件处理函数作为props传递" class="headerlink" title="将事件处理函数作为props传递"></a>将事件处理函数作为props传递</h4><p>通常，我们会在父组件中定义子组件的事件处理函数。为此将组件从父组件接收的prop作为事件处理函数传递。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个接收事件处理函数的子组件 </span><br><span class="line">function Button({ onClick, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={onClick}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这里作为父组件</span><br><span class="line">// 定义一个内部事件处理函数</span><br><span class="line">// 作为props传递给button组件</span><br><span class="line">function PlayButton({ movieName }) {</span><br><span class="line">  function handlePlayClick() {</span><br><span class="line">    alert(`正在播放 ${movieName}！`);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick={handlePlayClick}&gt;</span><br><span class="line">      播放 "{movieName}"</span><br><span class="line">    &lt;/Button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function UploadButton() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick={() =&gt; alert('正在上传！')}&gt;</span><br><span class="line">      上传图片</span><br><span class="line">    &lt;/Button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default function Toolbar() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;PlayButton movieName="魔女宅急便" /&gt;</span><br><span class="line">      &lt;UploadButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="命名事件处理函数prop"><a href="#命名事件处理函数prop" class="headerlink" title="命名事件处理函数prop"></a>命名事件处理函数prop</h4><p>对于浏览器内置组件（<code>&lt;button&gt;</code> 和 <code>&lt;div&gt;</code>），仅支持浏览器事件名称，例如，onclick。<strong>但是当我们构建自己的组件时，可以任意命名事件处理函数的prop。</strong></p>
<p>当组件支持多种交互时，可以根据不同的应用程序命名事件处理函数props。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 这里onClick接收的还是浏览器内置的&lt;button&gt;（小写）</span><br><span class="line">// 仍然需要使用 onClick prop，而自定义的 Button 组件接收到的 prop 名称还是可以定义。</span><br><span class="line">function Button({ onSmash, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={onSmash}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onSmash={() =&gt; alert('正在播放！')}&gt;</span><br><span class="line">        播放电影</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Button onSmash={() =&gt; alert('正在上传！')}&gt;</span><br><span class="line">        上传图片</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p><strong>事件处理函数还将捕获来自任何子组件的事件。</strong>通常，我们会说事件沿着树向上“冒泡”或者“传播”：他从事件发生的地方开始，然后沿着树向上传播。</p>
<p><strong>在React中所有的事件都会传播，除了onScroll，它仅适用于附加到的JSX标签中。</strong></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 当你点击button时，先触发他自身的onClick</span><br><span class="line">// 在执行父级div的onClick</span><br><span class="line">// 但是如果只点击了父级的那么只会触发父级本身的onClick</span><br><span class="line">export default function Toolbar() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="Toolbar" onClick={() =&gt; {</span><br><span class="line">      alert('你点击了 toolbar ！');</span><br><span class="line">    }}&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; alert('正在播放！')}&gt;</span><br><span class="line">        播放电影</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; alert('正在上传！')}&gt;</span><br><span class="line">        上传图片</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="阻止传播"><a href="#阻止传播" class="headerlink" title="阻止传播"></a>阻止传播</h4><p>事件处理函数接收一个**<u>事件对象</u><strong>作为唯一的参数。一般通常被称为<code>e</code>,代表`event（事件）。</strong><u><em>这个可以使用此对象读取事件的有关信息。</em></u>**</p>
<p>这个事件对象还允许阻止传播。例如：</p>
<p>当你点击按钮时：</p>
<ol>
<li>React 调用了传递给 <code>&lt;button&gt;</code> 的 <code>onClick</code> 处理函数。</li>
<li>定义在<button>中的处理函数执行了如下操作：<ul>
<li>调用 <code>e.stopPropagation()</code>，阻止事件进一步冒泡。</li>
<li>调用 <code>onClick</code> 函数，它是从 <code>Toolbar</code> 组件传递过来的 prop。</li>
</ul>
</button></li>
<li>在 <code>Toolbar</code> 组件中定义的函数，显示按钮对应的 alert。</li>
<li>由于传播被阻止，父级 <code>&lt;div&gt;</code> 的 <code>onClick</code> 处理函数不会执行。</li>
</ol>
<p>由于调用了 <code>e.stopPropagation()</code>，点击按钮现在将只显示一个 alert（来自 <code>&lt;button&gt;</code>），而并非两个（分别来自 <code>&lt;button&gt;</code> 和父级 toolbar <code>&lt;div&gt;</code>）。点击按钮与点击周围的 toolbar 不同，因此阻止传播对这个 UI 是有意义的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Button({ onClick, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={e =&gt; {</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      onClick();</span><br><span class="line">    }}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">export default function Toolbar() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="Toolbar" onClick={() =&gt; {</span><br><span class="line">      alert('你点击了 toolbar ！');</span><br><span class="line">    }}&gt;</span><br><span class="line">      &lt;Button onClick={() =&gt; alert('正在播放！')}&gt;</span><br><span class="line">        播放电影</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick={() =&gt; alert('正在上传！')}&gt;</span><br><span class="line">        上传图片</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>拓展：</p>
<p>少数情况下，你可能需要捕获子元素上的所有事件，<strong>即便它们阻止了传播</strong>。例如，你可能想对每次点击进行埋点记录，传播逻辑暂且不论。那么你可以通过在事件名称末尾添加 <code>Capture</code> 来实现这一点：</p>
<h5 id="onClickCapture捕获所有事件"><a href="#onClickCapture捕获所有事件" class="headerlink" title="onClickCapture捕获所有事件"></a><strong>onClickCapture</strong>捕获所有事件</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClickCapture={() =&gt; { /* 这会首先执行 */ }}&gt;</span><br><span class="line">  &lt;button onClick={e =&gt; e.stopPropagation()} /&gt;</span><br><span class="line">  &lt;button onClick={e =&gt; e.stopPropagation()} /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>每个事件分三个阶段传播：</p>
<ol>
<li>它向下传播，调用所有的 <code>onClickCapture</code> 处理函数。</li>
<li>它执行被点击元素的 <code>onClick</code> 处理函数。</li>
<li>它向上传播，调用所有的 <code>onClick</code> 处理函数。</li>
</ol>
<p>捕获事件对于路由或数据分析之类的代码很有用，但你可能不会在应用程序代码中使用它们。</p>
<h4 id="传递处理函数作为事件传播的代替方案"><a href="#传递处理函数作为事件传播的代替方案" class="headerlink" title="传递处理函数作为事件传播的代替方案"></a>传递处理函数作为事件传播的代替方案</h4><p>看这一段代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Button({ onClick, children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick={e =&gt; {</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      onClick();</span><br><span class="line">    }}&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此处的点击事件处理函数先执行了一段代码，<strong>然后</strong>调用了父组件传递的 <code>onClick</code> prop。</p>
<p>也可以在调用父元素<code>onClick</code>函数之前，添加其他代码。此模式是事件传播的另一种 <strong>替代方案</strong> 。它让子组件处理事件，同时也让父组件指定一些额外的行为。与事件传播不同，它并非自动。但使用这种模式的好处是你可以清楚地追踪因某个事件的触发而执行的整条代码链。</p>
<p>如果你依赖于事件传播，而且很难追踪哪些处理程序在执行，及其执行的原因，可以尝试这种方法。</p>
<h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>某些浏览器事件具有与事件相关联的默认行为。例如，点击 <code>&lt;form&gt;</code> 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面。</p>
<p>可以调用事件对象中的 <code>e.preventDefault()</code> 来阻止这种情况发生：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default function Signup() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit={e =&gt; {</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      alert('提交表单！');</span><br><span class="line">    }}&gt;</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">      &lt;button&gt;发送&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>不要混淆 <code>e.stopPropagation()</code> 和 <code>e.preventDefault()</code>。它们都很有用，但二者并不相关：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Event/stopPropagation"><code>e.stopPropagation()</code></a> 阻止触发绑定在外层标签上的事件处理函数。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Event/preventDefault"><code>e.preventDefault()</code></a> 阻止少数事件的默认浏览器行为。</li>
</ul>
<h4 id="事件函数可以包含副作用吗"><a href="#事件函数可以包含副作用吗" class="headerlink" title="事件函数可以包含副作用吗"></a>事件函数可以包含副作用吗</h4><p>当然可以！事件处理函数是执行副作用的最佳位置。</p>
<p>与渲染函数不同，事件处理函数不需要是 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/keeping-components-pure">纯函数</a>，因此它是用来 <em>更改</em> 某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，为了更改某些信息，你首先需要某种方式存储它。在 React 中，这是通过 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/state-a-components-memory">state（组件的记忆）</a> 来完成的。</p>
<h2 id="state：组件的记忆"><a href="#state：组件的记忆" class="headerlink" title="state：组件的记忆"></a>state：组件的记忆</h2><p>组件通常需要根据交互更改屏幕上显示的内容。在我们表单输入的时候应该更新字段、单机轮播图上的点击下一个应该更改的图片。组件需要“记住”这些东西：当前输入值、当前轮播图。在React中，这种组件持有的记忆被称为<code>state</code>。</p>
<p>当使用普通变量时，事件处理函数会更新局部的变量，但是没有达到预期的效果。</p>
<p>原因有二：</p>
<ul>
<li><strong>局部变量无法在多次渲染中持久化保存。</strong>当React在此渲染这个组件时，他会使用事件处理函数中最初的值重新开始渲染，<strong>他不会考虑之前局部变量的任何修改。</strong></li>
<li><strong>更新局部变量不会触发渲染。</strong>React没有意识它需要去使用新数据渲染数组。</li>
</ul>
<h3 id="如何使用新数据更新组件"><a href="#如何使用新数据更新组件" class="headerlink" title="如何使用新数据更新组件?"></a>如何使用新数据更新组件?</h3><p>需要做俩件事：</p>
<ol>
<li><strong>保留</strong>渲染之间的数据</li>
<li><strong>触发</strong>React使用新数据渲染组件（重新渲染）</li>
</ol>
<h3 id="这时候就引出了，主人公：useStateHook。"><a href="#这时候就引出了，主人公：useStateHook。" class="headerlink" title="这时候就引出了，主人公：useStateHook。"></a>这时候就引出了，主人公：<code>useState</code>Hook。</h3><p><code>useState</code>Hook提供了俩个功能：</p>
<ol>
<li><strong>State变量</strong>用于保存渲染间的数据。</li>
<li><strong>State setter函数</strong>更新变量并触发React再次渲染组件。</li>
</ol>
<h4 id="使用姿势（如何添加一个state变量）"><a href="#使用姿势（如何添加一个state变量）" class="headerlink" title="使用姿势（如何添加一个state变量）"></a>使用姿势（如何添加一个state变量）</h4><ol>
<li><p>现在顶部文件React导入<code>useState</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>定义state变量</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [index, setIndex] = useState(0);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>其中index为<code>State</code>变量，<code>setIndex</code>是对应的<code>setter</code>函数。</strong></p>
<p><strong>这里的 <code>[</code> 和 <code>]</code> 语法称为<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/a-javascript-refresher#array-destructuring">数组解构</a>，它允许你从数组中读取值。 <code>useState</code> 返回的数组总是正好有两项。</strong></p>
</li>
</ol>
<p>在React中，<code>useState</code>以及其他以<code>use</code>开头的函数都被称为<strong>Hook</strong></p>
<p>Hook是特殊的函数，只在React<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/render-and-commit#step-1-trigger-a-render">渲染</a>是有效。</p>
<p><strong><u><em>注意：</em></u></strong></p>
<p>Hooks，以<code>use</code>开头的函数，只能在组件或者**<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/reusing-logic-with-custom-hooks">自定义 Hook</a>** 的最顶层调用。**<u><em>不能在条件语句、循环语句或其他嵌套函数内调用 Hook。</em></u>**Hook是函数。</p>
<h3 id="深度剖析useState"><a href="#深度剖析useState" class="headerlink" title="深度剖析useState"></a>深度剖析<code>useState</code></h3><p>当调用<code>useState</code>时，是在告诉React你想让组件记住一些东西。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [index, setIndex] = useState(0);</span><br></pre></td></tr></tbody></table></figure>

<p>在这段代码中，我们希望React记住index。</p>
<p><code>useState</code>的唯一参数是state变量的<strong>初始值</strong>。这个例子中<code>index</code><strong>初始值</strong>被<code>useState(0)</code>设置为0。</p>
<p>每当我们组件渲染时，<code>useState</code>都会返回一个包含俩个值的数组：</p>
<ol>
<li><strong>state变量</strong>（index）会保存上次渲染的值。</li>
<li><strong>state setter函数</strong>（setIndex）可以更新state变量并触发React重新渲染组件。</li>
</ol>
<p>以下是具体的执行顺序：</p>
<ol>
<li><strong>组件进行第一次渲染</strong>。会将<code>index</code>初始值0传递给<code>useState</code>,他就会返回<code>[0,setIndex]</code>。这时候React会记住<code>0</code>是最新的值。</li>
<li><strong>更新了state。</strong>当用户点击按钮的时候，他会调用<code>setIndex(index+1)</code>。index初始值<code>0</code>,所以就会变成<code>setIndex(1)</code>。这将告诉React记住<code>index</code>是<code>1</code>触发下一次渲染。</li>
<li><strong>组件进行二次渲染。</strong>React仍然看到<code>useState(0)</code>,但是这时候React记住了<code>index</code>设置为<code>1</code>,他将返回<code>[1,setIndex]</code>。</li>
<li>后续渲染过程如此反复。</li>
</ol>
<p>我们可以为一个组件赋予多个state变量。并且这些组件可以拥有任意的多种类型的state变量。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line">import { sculptureList } from './data.js';</span><br><span class="line"></span><br><span class="line">export default function Gallery() {</span><br><span class="line">  const [index, setIndex] = useState(0);</span><br><span class="line">  const [showMore, setShowMore] = useState(false);</span><br><span class="line"></span><br><span class="line">  function handleNextClick() {</span><br><span class="line">    setIndex(index + 1);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleMoreClick() {</span><br><span class="line">    setShowMore(!showMore);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  let sculpture = sculptureList[index];</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick={handleNextClick}&gt;</span><br><span class="line">        Next</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;h2&gt;</span><br><span class="line">        &lt;i&gt;{sculpture.name} &lt;/i&gt; </span><br><span class="line">        by {sculpture.artist}</span><br><span class="line">      &lt;/h2&gt;</span><br><span class="line">      &lt;h3&gt;  </span><br><span class="line">        ({index + 1} of {sculptureList.length})</span><br><span class="line">      &lt;/h3&gt;</span><br><span class="line">      &lt;button onClick={handleMoreClick}&gt;</span><br><span class="line">        {showMore ? 'Hide' : 'Show'} details</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      {showMore &amp;&amp; &lt;p&gt;{sculpture.description}&lt;/p&gt;}</span><br><span class="line">      &lt;img </span><br><span class="line">        src={sculpture.url} </span><br><span class="line">        alt={sculpture.alt}</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果它们不相关，那么存在多个 state 变量是一个好主意，例如本例中的 <code>index</code> 和 <code>showMore</code>。但是，如果你发现经常同时更改两个 state 变量，那么最好将它们合并为一个。例如，如果你有一个包含多个字段的表单，那么有一个值为对象的 state 变量比每个字段对应一个 state 变量更方便。 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/choosing-the-state-structure">选择 state 结构</a>在这方面有更多提示。</p>
<h4 id="拓展：为什么React如何知道要返回哪个state？？"><a href="#拓展：为什么React如何知道要返回哪个state？？" class="headerlink" title="拓展：为什么React如何知道要返回哪个state？？"></a>拓展：为什么React如何知道要返回哪个state？？</h4><p> <a target="_blank" rel="noopener" href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React Hooks: not magic, just arrays</a></p>
<h4 id="State是隔离且私有的"><a href="#State是隔离且私有的" class="headerlink" title="State是隔离且私有的"></a>State是隔离且私有的</h4><p>State是屏幕上组件实例内部的状态。<strong>也就是说每次渲染都会产生完全隔离的state副本！</strong>一个改变会会影响另一个。</p>
<p>这是因为<code>state</code>与生命在模块顶部的普通变量不同的原因。State不依赖于特定的函数调用或在代码中的位置。<strong>他的作用域“只限于”屏幕上模块特定的区域。重复渲染组件，他们的<code>state</code>是分开存储的。</strong></p>
<p><strong>state完全私有于声明他的组件。父组件无法更改它。</strong></p>
<p><strong><u><em>State 变量仅用于在组件重渲染时保存信息。在单个事件处理函数中，普通变量就足够了。当普通变量运行良好时，不要引入 state 变量。</em></u></strong></p>
<h2 id="渲染和提交"><a href="#渲染和提交" class="headerlink" title="渲染和提交"></a>渲染和提交</h2><p>设想我们是一个厨师，把食材做成美味的菜肴。在这个场景下，React就是一个服务员。这种请求和提供UI的过程分为三步：</p>
<ol>
<li><strong>触发</strong>一次渲染（把客人的点单派发厨房）</li>
<li><strong>渲染</strong>组件（厨房准备订单）</li>
<li><strong>提交</strong>到DOM（将菜品放到桌子上）</li>
</ol>
<h3 id="步骤1：触发一次渲染"><a href="#步骤1：触发一次渲染" class="headerlink" title="步骤1：触发一次渲染"></a>步骤1：触发一次渲染</h3><p>触发渲染的原因有二：</p>
<ol>
<li>组件的<strong>初次渲染</strong>。</li>
<li>组件（或者其祖先之一）的<strong>状态发生了改变</strong></li>
</ol>
<h4 id="初次渲染"><a href="#初次渲染" class="headerlink" title="初次渲染"></a>初次渲染</h4><p>当应用启动的时候，会触发初次渲染，框架和沙箱有时候会隐藏这段代码，但是它通过调用目标DOM节点的 <a target="_blank" rel="noopener" href="https://react.docschina.org/reference/react-dom/client/createRoot"><code>createRoot</code></a>，然后组件调用<code>render</code>函数完成的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Image from './Image.js';</span><br><span class="line">import { createRoot } from 'react-dom/client';</span><br><span class="line"></span><br><span class="line">const root = createRoot(document.getElementById('root'))</span><br><span class="line">root.render(&lt;Image /&gt;);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="状态更新时重现渲染"><a href="#状态更新时重现渲染" class="headerlink" title="状态更新时重现渲染"></a>状态更新时重现渲染</h4><p>一旦组件被初次渲染，我们就可以通过<a target="_blank" rel="noopener" href="https://react.docschina.org/reference/react/useState#setstate"><code>set</code> 函数</a>更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。</p>
<h3 id="步骤2-React渲染你的组件"><a href="#步骤2-React渲染你的组件" class="headerlink" title="步骤2:React渲染你的组件"></a>步骤2:React渲染你的组件</h3><p>在触发初次渲染之后，React会调用组件的来确定屏幕上渲染显示的内容。<strong>“渲染中”</strong>即React在调用你的组件。</p>
<ul>
<li><strong>在初次渲染时</strong>，React会调用根组件。</li>
<li><strong>对于后续的渲染</strong>，React会调用内部状态更新触发了渲染的函数组件。</li>
</ul>
<p>这个过程是递归的：如果更新的组件会返回某个另外组件，那么React接下来就会渲染<em>那个</em>组件，如果哪个组件又返回了某个组件，那么React接下来会渲染<em>那个</em>组件。以此类推，这个过程会持续下去，知道没有更多的嵌套组件并且React确定知道哪些东西应该显示到屏幕上为止。</p>
<p>我们看个例子，React将会调用<code>Gallery（）</code>和<code>Image（）</code>若干次。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Gallery组件</span><br><span class="line">export default function Gallery() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;鼓舞人心的雕塑&lt;/h1&gt;</span><br><span class="line">      &lt;Image /&gt;</span><br><span class="line">      &lt;Image /&gt;</span><br><span class="line">      &lt;Image /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function Image() {</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      src="https://i.imgur.com/ZF6s192.jpg"</span><br><span class="line">      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// app</span><br><span class="line">import Gallery from './Gallery.js';</span><br><span class="line">import { createRoot } from 'react-dom/client';</span><br><span class="line"></span><br><span class="line">const root = createRoot(document.getElementById('root'))</span><br><span class="line">root.render(&lt;Gallery /&gt;);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>初次渲染中</strong>，React将会为<code>&lt;section&gt;</code>、<code>&lt;h1&gt;</code> 和三个 <code>&lt;img&gt;</code> 标签<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Document/createElement">创建 DOM 节点</a></li>
<li><strong>在一次重渲染过程中，</strong>React将计算它们的那些属性（如果有的话）自上次渲染以来已经更改。再下一步（提交阶段）之前，他不会对这些信息执行任何操作。</li>
</ul>
<p><em><strong><u>注意：</u></strong></em></p>
<p>渲染必须是一次 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/keeping-components-pure">纯计算</a>:</p>
<ul>
<li><strong>输入相同，输出相同。</strong>给定相同的输入，组件应该始终返回相同的JSX。就好比，食客点了西红柿沙拉，不应该收到洋葱沙拉！</li>
<li><strong>只做它们自己的事情。</strong>他不应该更改更改任何存在于渲染之前的对象或者变量。就好比一个订单不应该更改其他任何人的订单。</li>
</ul>
<p>否则，随着代码库复杂性的增加，可能会遇到令人困惑的错误和不可预测的行为。在“严格模式‘下开发时，React会调用每个组件函数俩次，这可以检测不纯函数引起的错误。</p>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><p>如果更新的组件在树中的位置非常高，渲染更新后的组件内部所有嵌套组件的默认行为将不会获得最佳性能。如果你遇到了性能问题，<a target="_blank" rel="noopener" href="https://reactjs.org/docs/optimizing-performance.html">性能</a> 章节描述了几种可选的解决方案 。<strong>不要过早进行优化！</strong></p>
<h3 id="步骤3-React把更改提交到DOM上"><a href="#步骤3-React把更改提交到DOM上" class="headerlink" title="步骤3:React把更改提交到DOM上"></a>步骤3:React把更改提交到DOM上</h3><p>在渲染（调用）你的组件之后，React将会修改DOM</p>
<ul>
<li><strong>对于初次渲染，</strong>React会使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild"><code>appendChild()</code></a>DOM API将其创建所有的DOM节点放在屏幕上。</li>
<li><strong>对于重渲染，</strong>React将应用最少的必要操作（在渲染时计算！），以使得DOM与最新的渲染输出互相匹配。</li>
</ul>
<p><strong>React仅在渲染之间存在差异时才会更新DOM节点。</strong></p>
<p>有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。注意，你可以添加一些文本到 <code>&lt;input&gt;</code> 标签，更新它的 <code>value</code>，但是文本不会在组件重渲染时消失：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function Clock({ time }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{time}&lt;/h1&gt;</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这个例子之所以会正常运行，是因为在最后一步中，React 只会使用最新的 <code>time</code> 更新 <code>&lt;h1&gt;</code> 标签的内容。它看到 <code>&lt;input&gt;</code> 标签出现在 JSX 中与上次相同的位置，因此 React 不会修改 <code>&lt;input&gt;</code> 标签或它的 <code>value</code>！</p>
<h3 id="浏览器绘制"><a href="#浏览器绘制" class="headerlink" title="浏览器绘制"></a>浏览器绘制</h3><p>在渲染完成并且React更新DOM之后，浏览器就会重新绘制屏幕。尽管这个过程称为“浏览器渲染”（“browser rendering”），这里还是称为“绘制”（“painting”），以避免在这些文档的其余部分中出现混淆。</p>
<h2 id="state如同一张快照"><a href="#state如同一张快照" class="headerlink" title="state如同一张快照"></a>state如同一张快照</h2><p>也许state变量看起来就和一般的可读写的JavaScript变量类似。但state在其表现出的特性上更像是一张快照。设置他不会更爱你已有的state变量，但会触发重新渲染。</p>
<h3 id="设置state会触发渲染"><a href="#设置state会触发渲染" class="headerlink" title="设置state会触发渲染"></a>设置state会触发渲染</h3><p>你可能会认为你的用户界面会直接对点击之类的用户输入做出相应并发生变化。在React中，他的工作方式与这种思维模型略有不同。上一章节我们知道通过设置<code>state</code>请求重新渲染。这就意味着要使界面对输入做出反应，需要使用设置state。</p>
<p>看个例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Form() {</span><br><span class="line">  const [isSent, setIsSent] = useState(false);</span><br><span class="line">  const [message, setMessage] = useState('Hi!');</span><br><span class="line">  if (isSent) {</span><br><span class="line">    return &lt;h1&gt;Your message is on its way!&lt;/h1&gt;</span><br><span class="line">  }</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit={(e) =&gt; {</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      setIsSent(true);</span><br><span class="line">      sendMessage(message);</span><br><span class="line">    }}&gt;</span><br><span class="line">      &lt;textarea</span><br><span class="line">        placeholder="Message"</span><br><span class="line">        value={message}</span><br><span class="line">        onChange={e =&gt; setMessage(e.target.value)}</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button type="submit"&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function sendMessage(message) {</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>当单击按钮时会发生以下情况：</p>
<ol>
<li>执行 <code>onSubmit</code> 事件处理函数。</li>
<li><code>setIsSent(true)</code> 将 <code>isSent</code> 设置为 <code>true</code> 并排列一个新的渲染。</li>
<li>React 根据新的 <code>isSent</code> 值重新渲染组件。</li>
</ol>
<h3 id="渲染会及时生出一张快照"><a href="#渲染会及时生出一张快照" class="headerlink" title="渲染会及时生出一张快照"></a>渲染会及时生出一张快照</h3><p><a target="_blank" rel="noopener" href="https://react.docschina.org/learn/render-and-commit#step-2-react-renders-your-components">“正在渲染”</a>就意味着React正在调用组件—- 一个函数。你从该函数返回的JSX就像是UI的一张及时的快照。它的props、事件处理函数和内部变量都是<strong>根据当前渲染时的state被计算出来的。</strong></p>
<p>相较于照片或电影画面不同，你返回的UI“快照”是可交互的。他其中包含着类似事件处理函数的逻辑，这些逻辑对于指定如何输入作出响应。React随后会更新屏幕来匹配这张快照，并绑定事件处理函数。因此，按下按钮即会触发你的JSX的点击事件处理函数。</p>
<p>当React重新渲染一组件时：</p>
<ol>
<li>React会再次调用你的函数</li>
<li>函数会返回新的JSX快照</li>
<li>React会更新界面以匹配返回的快照</li>
</ol>
<p>作为一个组件的记忆，<code>state</code>不同于在你的函数返回之后就会消失的普通变量。state实际是“活”在React本身– 就像摆在一个架子上！– 位于你的函数之外。当React调用组件时，他会为特定的那一次渲染提供一张state快照。你的组件会在会在JSX中返回一张包含一整套新的props和事件处理函数的UI快照，其中所有的值都是<strong>根据一次渲染中state的值</strong>被计算出来的！</p>
<p>下面看个例子：</p>
<p>试想下结果！</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Counter() {</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{number}&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      }}&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><em>点击按钮后其实发现，每次点击<code>number</code>递增一次！！！</em></p>
<p><strong>设置state只会为下一次渲染变更state的值。</strong>在第一次渲染期间，<code>number</code>为<code>0</code>。这也解释了为什么在<strong>那次渲染中的</strong> <code>onClick</code> 处理函数中，即便在调用了 <code>setNumber(number + 1)</code> 之后，<code>number</code> 的值也仍然是 <code>0</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button onClick={() =&gt; {</span><br><span class="line">  setNumber(number + 1);</span><br><span class="line">  setNumber(number + 1);</span><br><span class="line">  setNumber(number + 1);</span><br><span class="line">}}&gt;+3&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>分析下这个按钮点击事件处理函数通知React要做的事情：</p>
<ol>
<li><code>setNumber(number + 1)</code>：<code>number</code> 是 <code>0</code> 所以 <code>setNumber(0 + 1)</code>。<ul>
<li>React 准备在下一次渲染时将 <code>number</code> 更改为 <code>1</code>。</li>
</ul>
</li>
<li><code>setNumber(number + 1)</code>：<code>number</code> 是<code>0</code> 所以 <code>setNumber(0 + 1)</code>。<ul>
<li>React 准备在下一次渲染时将 <code>number</code> 更改为 <code>1</code>。</li>
</ul>
</li>
<li><code>setNumber(number + 1)</code>：<code>number</code> 是<code>0</code> 所以 <code>setNumber(0 + 1)</code>。<ul>
<li>React 准备在下一次渲染时将 <code>number</code> 更改为 <code>1</code>。</li>
</ul>
</li>
</ol>
<p>尽管调用了三次 <code>setNumber(number + 1)</code>，但是在<strong>这次渲染的</strong>的事件处理函数中<code>number</code>会一直是<code>0</code>，所以你会三次将state设置为<code>1</code>。这就是为什么你在事件处理函数执行完后，React重新渲染的组件中的<code>number</code>等于<code>1</code>而不是<code>3</code></p>
<p>其实就是可以把state变量放入这次渲染中。由于<strong>这次渲染</strong>中的state变量就是<code>0</code>，其实事件处理函数就是以下这种：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick={() =&gt; {</span><br><span class="line">  setNumber(0 + 1);</span><br><span class="line">  setNumber(0 + 1);</span><br><span class="line">  setNumber(0 + 1);</span><br><span class="line">}}&gt;+3&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>所以对于下一次渲染来说，<code>number</code>是<code>1</code>，因此<strong>那次渲染中的</strong>点击事件处理函数就是这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick={() =&gt; {</span><br><span class="line">  setNumber(1 + 1);</span><br><span class="line">  setNumber(1 + 1);</span><br><span class="line">  setNumber(1 + 1);</span><br><span class="line">}}&gt;+3&lt;/button&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>以上这就是为什么每次都是递增<code>1</code>。</p>
<h3 id="随着时间变化的state"><a href="#随着时间变化的state" class="headerlink" title="随着时间变化的state"></a>随着时间变化的state</h3><p>来看来段代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Counter() {</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{number}&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        alert(number);</span><br><span class="line">      }}&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码会出现 <code>alert</code>先显示<code>0</code>,页面显示累加后的。也就是<code>alert</code>会先显示上一次的数值，页面在显示。</p>
<p>在<code>alert</code>加上记时器，使得在组件重新渲染<strong>之后</strong>才触发。又会怎么样呢？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Counter() {</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{number}&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        setTimeout(() =&gt; {</span><br><span class="line">          alert(number);</span><br><span class="line">        }, 3000);</span><br><span class="line">      }}&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这时候就会发现页面先渲染出累加后的数值，<code>alert</code>才会输出累计后的数值。</p>
<p>到提示框运行时，React中存储的state可能已经发生了改变，但他是使用用户与之交互时的快照进行调度的！</p>
<p><strong>一个state变量的值永远不会在一次渲染的内部发生变化</strong>，即使事件处理函数的代码是异步的。在<strong>那个渲染的</strong><code>onClick</code>内部，<code>number</code>的值即使在调用的<code>setNumber(number + 5)</code>之后也是<code>0</code>。它的值是在React通过调用你的组件“获取UI的快照”时就被“固定”了。</p>
<p><strong>React 会使 state 的值始终”固定“在一次渲染的各个事件处理函数内部。</strong> 你无需担心代码运行时 state 是否发生了变化。</p>
<h2 id="把一系列state更新加入队列"><a href="#把一系列state更新加入队列" class="headerlink" title="把一系列state更新加入队列"></a>把一系列state更新加入队列</h2><h3 id="React会对state更新进行批处理"><a href="#React会对state更新进行批处理" class="headerlink" title="React会对state更新进行批处理"></a>React会对state更新进行批处理</h3><p>在上节这个示例中，我们发现当按钮点击后，组件页面渲染数值一直是每次累加一次的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Counter() {</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{number}&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      }}&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://react.docschina.org/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time">每一次渲染的 state 值都是固定的</a>，在第一次渲染的事件处理函数内部的<code>number</code>值总是<code>0</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br><span class="line">setNumber(0 + 1);</span><br></pre></td></tr></tbody></table></figure>

<p>在Reac机制里，<strong>React会等到事件处理函数中的所有代码都运行完毕在处理你的state更新。</strong>这也就是为什么重新渲染只会发生在所有这些<code>setNumber()</code>调用<strong>之后的原因</strong>。</p>
<p>就好比，点餐时。服务员不会在你说第一道菜的时候，就去厨房下单，而是等你，把菜点完、如有修改修改完后，再一次性去下单。</p>
<p>这样就可以更新多个state变量–甚至来自多个组件的state变量–而不会触发太多的 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/render-and-commit#re-renders-when-state-updates">重新渲染</a>。这样也意味着只有在我们的事件处理函数以及其中任何代码执行完成<strong>之后</strong>，UI才会更新。这种特性也就是<strong>批处理</strong>，他会使React应用运行得更快。这样也可以帮助我们避免处理只更新了一部分state变量的令人困惑的“半成品”渲染。</p>
<p><strong>React不会垮<em>多个</em>需要刻意触发的事件（如点击）进行批处理</strong>–每次点击都是单独处理的。React只会在一般来说安全的情况下才进行批处理。例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。</p>
<h3 id="在下次渲染前读次更新同一个state"><a href="#在下次渲染前读次更新同一个state" class="headerlink" title="在下次渲染前读次更新同一个state"></a>在下次渲染前读次更新同一个state</h3><p>如果想在下次渲染之前多次更新同一个state，我们可以使用<code>setNumber(n =&gt; n + 1)</code>这样传入一个根据队列中的前一个state计算下一个state函数，而不是像<code>setNumber(number + 1)</code>这样传入<strong>下一个state的值</strong>。这是告诉React“用state值做某事”而不是仅仅替换它的方法。</p>
<p>现在尝试递增计数器：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Counter() {</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;{number}&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">        setNumber(n =&gt; n + 1);</span><br><span class="line">      }}&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在这里，<code>n =&gt; n + 1</code>被称为<strong>更新函数</strong>。当我们给他传递一个state设置函数时：</p>
<ol>
<li>React会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。</li>
<li>在下一次渲染期间，React会遍历队列并更新之后的最终state。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setNumber(n =&gt; n + 1);</span><br><span class="line">setNumber(n =&gt; n + 1);</span><br><span class="line">setNumber(n =&gt; n + 1);</span><br></pre></td></tr></tbody></table></figure>

<p>以下是React在执行事件处理函数时处理这几行代码的过程：</p>
<ol>
<li><code>setNumber(n =&gt; n + 1)</code>：<code>n =&gt; n + 1</code> 是一个函数。React 将它加入队列。</li>
<li><code>setNumber(n =&gt; n + 1)</code>：<code>n =&gt; n + 1</code> 是一个函数。React 将它加入队列。</li>
<li><code>setNumber(n =&gt; n + 1)</code>：<code>n =&gt; n + 1</code> 是一个函数。React 将它加入队列。</li>
</ol>
<p>在下次渲染期间调用<code>useState</code>时，React会遍历队列。之前的<code>number</code>state的值是<code>0</code>，所以这就是React作为参数<code>n</code>传递给第一个更新函数的值。然后React会获取上一个更新函数的返回值，并将其作为<code>n</code>传递给下一个更新函数，以此类推：</p>
<table>
<thead>
<tr>
<th align="center"><strong>更新队列</strong></th>
<th align="center"><strong><code>n</code></strong></th>
<th align="center"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>0</code></td>
<td align="center"><code>0 + 1 = 1</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>1</code></td>
<td align="center"><code>1 + 1 = 2</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>2</code></td>
<td align="center"><code>2 + 1 = 3</code></td>
</tr>
</tbody></table>
<h3 id="如果在替换state后更新state会发生什么"><a href="#如果在替换state后更新state会发生什么" class="headerlink" title="如果在替换state后更新state会发生什么"></a>如果在替换state后更新state会发生什么</h3><p>看看下面这个例子，思考下下一次<code>number</code>渲染的值是什么？</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick={() =&gt; {</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">}}&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实际结果是：每次递增6</strong></p>
<p>这个事件处理函数告诉React要做的事情：</p>
<ol>
<li><code>setNumber(number + 5)</code>：<code>number</code> 为 <code>0</code>，所以 <code>setNumber(0 + 5)</code>。React 将 <em>“替换为 <code>5</code>”</em> 添加到其队列中。</li>
<li><code>setNumber(n =&gt; n + 1)</code>：<code>n =&gt; n + 1</code> 是一个更新函数。 React 将 <strong>该函数</strong> 添加到其队列中。</li>
</ol>
<p>在下一次渲染期间，React会遍历state队列：</p>
<table>
<thead>
<tr>
<th>更新队列</th>
<th><code>n</code></th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>“替换为 <code>5</code>”</td>
<td><code>0</code>（未使用）</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>n =&gt; n + 1</code></td>
<td><code>5</code></td>
<td><code>5 + 1 = 6</code></td>
</tr>
</tbody></table>
<p>React会保存<code>6</code>为最终结果并从<code>useState</code>中返回。</p>
<p>注意：其实这时候就可以发现，<code>setState(x)</code>实际上会像<code>setState(n =&gt; x)</code>一样运行，只不过没有使用<code>n</code>!</p>
<h3 id="如果在更新state后替换state会发生什么"><a href="#如果在更新state后替换state会发生什么" class="headerlink" title="如果在更新state后替换state会发生什么"></a>如果在更新state后替换state会发生什么</h3><p>看看这例子，你认为<code>number</code>在下一次渲染中的值是什么</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick={() =&gt; {</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(42);</span><br><span class="line">}}&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实际结果：第一次变更为<code>42</code>,后续一直为<code>42</code>。</strong></p>
<p>以下是 React 在执行事件处理函数时处理这几行代码的过程：</p>
<ol>
<li><code>setNumber(number + 5)</code>：<code>number</code> 为 <code>0</code>，所以 <code>setNumber(0 + 5)</code>。React 将 <em>“替换为 <code>5</code>”</em> 添加到其队列中。</li>
<li><code>setNumber(n =&gt; n + 1)</code>：<code>n =&gt; n + 1</code> 是一个更新函数。React 将该函数添加到其队列中。</li>
<li><code>setNumber(42)</code>：React 将 <em>“替换为 <code>42</code>”</em> 添加到其队列中。</li>
</ol>
<p>在下一次渲染期间，React 会遍历 state 队列：</p>
<table>
<thead>
<tr>
<th>更新队列</th>
<th><code>n</code></th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>“替换为 <code>5</code>”</td>
<td><code>0</code>（未使用）</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>n =&gt; n + 1</code></td>
<td><code>5</code></td>
<td><code>5 + 1 = 6</code></td>
</tr>
<tr>
<td>“替换为 <code>42</code>”</td>
<td><code>6</code>（未使用）</td>
<td><code>42</code></td>
</tr>
</tbody></table>
<p>然后 React 会保存 <code>42</code> 为最终结果并从 <code>useState</code> 中返回。</p>
<p>总而言之，以下是我们可以考虑传递给<code>setNumber</code>state设置函数的内容：</p>
<ul>
<li><strong>一个更新函数</strong>（例如：<code>n =&gt; n + 1</code>）会被添加到队列中。</li>
<li><strong>任何其他的值</strong>（例如：数字<code>5</code>）会导致“替换为<code>5</code>”被添加到队列中，已经在队列中的内容会被忽略。</li>
</ul>
<p>事件处理函数执行完成之后，React将重新触发渲染。再重新渲染期间，React将处理队列。更新函数会在渲染期间执行，因此<strong>更新函数必须是</strong> <strong><a target="_blank" rel="noopener" href="https://react.docschina.org/learn/keeping-components-pure">纯函数</a></strong> 并且只返回结果。不要尝试从他内部设置state或者执行其他副作用。在严格模式下，React会更新每个更新函数俩次（但是丢弃第二个结果），以便帮助发现错误。</p>
<h3 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h3><p>通常使用相应的state变量的第一个字母来命名更新函数的的参数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setEnabled(e =&gt; !e);</span><br><span class="line">setLastName(ln =&gt; ln.reverse());</span><br><span class="line">setFriendCount(fc =&gt; fc * 2);</span><br></pre></td></tr></tbody></table></figure>

<p>另一个常见的惯例是重复使用完整的 state 变量名称，如 <code>setEnabled(enabled =&gt; !enabled)</code>，或使用前缀，如 <code>setEnabled(prevEnabled =&gt; !prevEnabled)</code>。</p>
<h2 id="更新state中的对象"><a href="#更新state中的对象" class="headerlink" title="更新state中的对象"></a>更新state中的对象</h2><p>state中可以保存任意类型的<strong>JavaScript</strong>值，包括对象。但是，在修改对象的时候不应该直接修改存放在<strong>React state</strong>中的对象。当我们想更新一个对象时，需要创建一个新的对象（或者将其拷贝一份），然后将state更次为此对象。</p>
<h3 id="什么是mutation"><a href="#什么是mutation" class="headerlink" title="什么是mutation"></a>什么是mutation</h3><p>我们可以在state中存放任意类型的JavaScript值。</p>
<p>我们在state中存放的数字、字符串和布尔值，这些类型的值在JavaScript中是不可变（immutable）的，这意味着它们不能被改变或是只读的。这些值可以通过替换它们的值来触发下一次重新渲染。</p>
<h4 id="state存放数字"><a href="#state存放数字" class="headerlink" title="state存放数字"></a>state存放数字</h4><p>state<code>x</code>从<code>0</code>到<code>5</code>，数字<code>0</code>本身没有发生改变。在JavaScript中，无法对内置的原始值，如数字、字符串和布尔值，进行任何更改。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [x,setX] = useState(0)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="state存放对象"><a href="#state存放对象" class="headerlink" title="state存放对象"></a>state存放对象</h4><p><strong>当我们改变对象本身的内容时，就制造了一个mutation</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [position, setPosition] = useState({ x: 0, y: 0 });</span><br></pre></td></tr></tbody></table></figure>

<p>严格来说，React state中存放的对象是可变的，但是应该像处理数字、布尔值、字符串一样视为不可变。当要改变的时候，应该考虑去替换它们的值，而不是对他们进行修改。</p>
<h3 id="将state视为只读的"><a href="#将state视为只读的" class="headerlink" title="将state视为只读的"></a>将state视为只读的</h3><p>在React中我们应该<strong>将所有放在state中的JavaScript对象都视为只读的。</strong></p>
<p>我们来看这个例子，我们使用存放在state中的对象来表示指针当前的位置。当我们在预览区域触发或移动光标时，红色移动。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line">export default function MovingDot() {</span><br><span class="line">  const [position, setPosition] = useState({</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  });</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">    onPointerMove={e =&gt; {</span><br><span class="line"> 			setPosition({</span><br><span class="line">   			x: e.clientX,</span><br><span class="line">    		y: e.clientY	</span><br><span class="line"> 			 })</span><br><span class="line">			}}</span><br><span class="line">      style={{</span><br><span class="line">        position: 'relative',</span><br><span class="line">        width: '100vw',</span><br><span class="line">        height: '100vh',</span><br><span class="line">      }}&gt;</span><br><span class="line">      &lt;div style={{</span><br><span class="line">        position: 'absolute',</span><br><span class="line">        backgroundColor: 'red',</span><br><span class="line">        borderRadius: '50%',</span><br><span class="line">        transform: `translate(${position.x}px, ${position.y}px)`,</span><br><span class="line">        left: -10,</span><br><span class="line">        top: -10,</span><br><span class="line">        width: 20,</span><br><span class="line">        height: 20,</span><br><span class="line">      }} /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>为了真正 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/state-as-a-snapshot#setting-state-triggers-renders">触发一次重新渲染</a>，<strong>我们需要创建一个新的对象并把它传递给state的设置函数</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onPointerMove={e =&gt; {</span><br><span class="line">  setPosition({</span><br><span class="line">    x: e.clientX,</span><br><span class="line">    y: e.clientY</span><br><span class="line">  });</span><br><span class="line">}}</span><br></pre></td></tr></tbody></table></figure>

<p>通过使用<code>setPosition</code>,你在告诉React：</p>
<ul>
<li>使用这个新的对象替换<code>positon</code>的值</li>
<li>然后再次渲染这个组件</li>
</ul>
<h4 id="局部的mutation是可以接受的"><a href="#局部的mutation是可以接受的" class="headerlink" title="局部的mutation是可以接受的"></a>局部的mutation是可以接受的</h4><p>像这样的代码是有问题的，因为它改变了state中现有的对象：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position.x = e.clientX;</span><br><span class="line">position.y = e.clientY;</span><br></pre></td></tr></tbody></table></figure>

<p>但是像这样的代码就<strong>没有任何问题</strong>，因为改变的是刚刚创建的一个循对象，并将这个对象传递给了state：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const nextPosition = {};</span><br><span class="line">nextPosition.x = e.clientX;</span><br><span class="line">nextPosition.y = e.clientY;</span><br><span class="line">setPosition(nextPosition);</span><br></pre></td></tr></tbody></table></figure>

<p>这种写法完全等于这这写法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setPosition({</span><br><span class="line">  x: e.clientX,</span><br><span class="line">  y: e.clientY</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>只有改变处于state中的<strong>现有</strong>对象时，mutation才会成为问题。而修改一个刚刚创建的对象就不会出现任何问题，因为<strong>还没有其他代码引用它。</strong>改变它并不会意外的影响到其他依赖它的东西。这叫做“局部mutation”。我们也可以在 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/keeping-components-pure#local-mutation-your-components-little-secret">在渲染的过程中</a> 进行“局部mutation”的操作。这种操作既便捷又没有任何问题！</p>
<h3 id="使用展开语法复制对象"><a href="#使用展开语法复制对象" class="headerlink" title="使用展开语法复制对象"></a>使用展开语法复制对象</h3><p>在之前的例子，都会根据指针的位置创建出一个新的<code>position</code>对象。当我们只需要改变一个属性值的时候，也或者是将<strong>现有</strong>数据作为新对象的一部分。</p>
<p>看下面的例子，输入框并不会直接正常运行，因为<code>onChange</code>直接修改了state：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Form() {</span><br><span class="line">  const [person, setPerson] = useState({</span><br><span class="line">    firstName: 'Barbara',</span><br><span class="line">    lastName: 'Hepworth',</span><br><span class="line">    email: 'bhepworth@sculpture.com'</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  function handleFirstNameChange(e) {</span><br><span class="line">    person.firstName = e.target.value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleLastNameChange(e) {</span><br><span class="line">    person.lastName = e.target.value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleEmailChange(e) {</span><br><span class="line">    person.email = e.target.value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        First name:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.firstName}</span><br><span class="line">          onChange={handleFirstNameChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Last name:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.lastName}</span><br><span class="line">          onChange={handleLastNameChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Email:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.email}</span><br><span class="line">          onChange={handleEmailChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        {person.firstName}{' '}</span><br><span class="line">        {person.lastName}{' '}</span><br><span class="line">        ({person.email})</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>以上的，这段代码直接修改了上一次渲染中的state：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.firstName = e.target.value;</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们想在获取<code>firstName</code>的需求，最可靠的办法就是创建一个新的对象将它传递给<code>stePerson</code>。但是在这里，我们还需要将<strong>当前的数据复制到新对象中</strong>，因为我们只改了一个字段。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setPerson({</span><br><span class="line">  firstName: e.target.value, // 从 input 中获取新的 first name</span><br><span class="line">  lastName: person.lastName,</span><br><span class="line">  email: person.email</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>我们也可以使用<code>...</code><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals">对象展开</a> 语法，这样就不需要单独复制某个属性。这里注意：<strong>新的属性值应该放在最后。</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setPerson({</span><br><span class="line">  ...person, // 复制上一个 person 中的所有字段</span><br><span class="line">  firstName: e.target.value // 但是覆盖 firstName 字段 </span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>这样就可以看来，并没有为每个输入框单独生命一个state。对于大型表单，将所有数据都放在同一个对象中是非常方便的–前提是必须要正确地更新它！</p>
<p><strong>请注意<code>...</code>展开愈发本质是“浅拷贝”—它只会复制一层。这样就使得它的执行速度很快，这也意味着我们要更新一个嵌套属性时，就必须多次使用展开语法。</strong></p>
<h4 id="使用一个事件处理函数来更新多个字段"><a href="#使用一个事件处理函数来更新多个字段" class="headerlink" title="使用一个事件处理函数来更新多个字段"></a>使用一个事件处理函数来更新多个字段</h4><p>我们也可以在对象的定义中使用<code>[xxx]</code>括号来实现属性的动态命名。</p>
<p>看下面这个例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">export default function Form() {</span><br><span class="line">  const [person, setPerson] = useState({</span><br><span class="line">    firstName: 'Barbara',</span><br><span class="line">    lastName: 'Hepworth',</span><br><span class="line">    email: 'bhepworth@sculpture.com'</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  function handleChange(e) {</span><br><span class="line">    setPerson({</span><br><span class="line">      ...person,</span><br><span class="line">      [e.target.name]: e.target.value</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        First name:</span><br><span class="line">        &lt;input</span><br><span class="line">          name="firstName"</span><br><span class="line">          value={person.firstName}</span><br><span class="line">          onChange={handleChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Last name:</span><br><span class="line">        &lt;input</span><br><span class="line">          name="lastName"</span><br><span class="line">          value={person.lastName}</span><br><span class="line">          onChange={handleChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Email:</span><br><span class="line">        &lt;input</span><br><span class="line">          name="email"</span><br><span class="line">          value={person.email}</span><br><span class="line">          onChange={handleChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        {person.firstName}{' '}</span><br><span class="line">        {person.lastName}{' '}</span><br><span class="line">        ({person.email})</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在这里，<code>e.target.name</code> 引用了 <code>&lt;input&gt;</code> 这个 DOM 元素的 <code>name</code> 属性。</p>
<h3 id="更新一个嵌套对象"><a href="#更新一个嵌套对象" class="headerlink" title="更新一个嵌套对象"></a>更新一个嵌套对象</h3><p>如果出现了嵌套对象：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const [person, setPerson] = useState({</span><br><span class="line">  name: 'Niki de Saint Phalle',</span><br><span class="line">  artwork: {</span><br><span class="line">    title: 'Blue Nana',</span><br><span class="line">    city: 'Hamburg',</span><br><span class="line">    image: 'https://i.imgur.com/Sd1AgUOm.jpg',</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>如果想要更新 <code>person.artwork.city</code> 的值，用mutation来实现的方法就很好理解了：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.artwork.city = 'New Delhi';</span><br></pre></td></tr></tbody></table></figure>

<p>但是在React中，需要将state是为不可变得！如果要修改<code>city</code>的值，先要创建一个新的<code>artwork</code>对象（其中预先填充上一个<code>artworkd</code>对象中的数据）,然后创建一个你的<code>person</code>对象，并且使得其中的<code>artwork</code>属性指向新创建的<code>artwork</code>对象：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const nextArtwork = { ...person.artwork, city: 'new ork'}</span><br><span class="line">const nextPerson = { ...person, artwork: nextArtwork}</span><br><span class="line">setPerson(nextPerson)</span><br></pre></td></tr></tbody></table></figure>

<p>或者，也可以写成一个函数调用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setPerson({</span><br><span class="line">  ...person, // 复制其它字段的数据 </span><br><span class="line">  artwork: { // 替换 artwork 字段 </span><br><span class="line">    ...person.artwork, // 复制之前 person.artwork 中的数据</span><br><span class="line">    city: 'New Delhi' // 但是将 city 的值替换为 New Delhi！</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h4 id="对象并非是嵌套的"><a href="#对象并非是嵌套的" class="headerlink" title="对象并非是嵌套的"></a>对象并非是嵌套的</h4><p>下面这个对象从代码上来看是“嵌套的”：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = {</span><br><span class="line">  name: 'Niki de Saint Phalle',</span><br><span class="line">  artwork: {</span><br><span class="line">    title: 'Blue Nana',</span><br><span class="line">    city: 'Hamburg',</span><br><span class="line">    image: 'https://i.imgur.com/Sd1AgUOm.jpg',</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>其实，思考对象的特性时（key：value），“嵌套”并不是一个非常准确的方式。其实这个对象在运行时，会被解释为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = {</span><br><span class="line">  title: 'Blue Nana',</span><br><span class="line">  city: 'Hamburg',</span><br><span class="line">  image: 'https://i.imgur.com/Sd1AgUOm.jpg',</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">let obj2 = {</span><br><span class="line">  name: 'Niki de Saint Phalle',</span><br><span class="line">  artwork: obj1</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这么看来其实<code>obj1</code>并不处于<code>obj2</code>的内部。同时，下面代码中<code>obj3</code>中的属性也可以指向<code>obj1</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = {</span><br><span class="line">  title: 'Blue Nana',</span><br><span class="line">  city: 'Hamburg',</span><br><span class="line">  image: 'https://i.imgur.com/Sd1AgUOm.jpg',</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">let obj2 = {</span><br><span class="line">  name: 'Niki de Saint Phalle',</span><br><span class="line">  artwork: obj1</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">let obj3 = {</span><br><span class="line">  name: 'Copycat',</span><br><span class="line">  artwork: obj1</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果你直接修改 <code>obj3.artwork.city</code>，就会同时影响 <code>obj2.artwork.city</code> 和 <code>obj1.city</code>。这是因为 <code>obj3.artwork</code>、<code>obj2.artwork</code> 和 <code>obj1</code> 都指向同一个对象。当你用“嵌套”的方式看待对象时，很难看出这一点。相反，它们是相互独立的对象，只不过是用属性“指向”彼此而已。</p>
<h3 id="使用Immer编写简介的更新逻辑"><a href="#使用Immer编写简介的更新逻辑" class="headerlink" title="使用Immer编写简介的更新逻辑"></a>使用Immer编写简介的更新逻辑</h3><p>如果state有多层的嵌套，应该考虑将 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/choosing-the-state-structure#avoid-deeply-nested-state">将其扁平化</a>。但是同时，不想改拜年state的数据结构，我们可以使用<a target="_blank" rel="noopener" href="https://github.com/immerjs/use-immer">Immer</a> 这个库，他可以让你使用简便但是可以直接修改的语法编写代码，并会处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatePerson(draft =&gt; {</span><br><span class="line">  draft.artwork.city = 'Lagos';</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>不同于一般的mutation，他并不会覆盖之前的state！</p>
<h4 id="Immer-是如何运行的？"><a href="#Immer-是如何运行的？" class="headerlink" title="Immer 是如何运行的？"></a>Immer 是如何运行的？</h4><p>由 Immer 提供的 <code>draft</code> 是一种特殊类型的对象，被称为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 <code>draft</code> 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。</p>
<h4 id="如何使用Immer"><a href="#如何使用Immer" class="headerlink" title="如何使用Immer"></a>如何使用Immer</h4><p>尝试使用 Immer:</p>
<ol>
<li>运行 <code>npm install use-immer</code> 添加 Immer 依赖</li>
<li>用 <code>import { useImmer } from 'use-immer'</code> 替换掉 <code>import { useState } from 'react'</code></li>
</ol>
<p>看以下例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import { useImmer } from 'use-immer';</span><br><span class="line"></span><br><span class="line">export default function Form() {</span><br><span class="line">  const [person, updatePerson] = useImmer({</span><br><span class="line">    name: 'Niki de Saint Phalle',</span><br><span class="line">    artwork: {</span><br><span class="line">      title: 'Blue Nana',</span><br><span class="line">      city: 'Hamburg',</span><br><span class="line">      image: 'https://i.imgur.com/Sd1AgUOm.jpg',</span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  function handleNameChange(e) {</span><br><span class="line">    updatePerson(draft =&gt; {</span><br><span class="line">      draft.name = e.target.value;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleTitleChange(e) {</span><br><span class="line">    updatePerson(draft =&gt; {</span><br><span class="line">      draft.artwork.title = e.target.value;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleCityChange(e) {</span><br><span class="line">    updatePerson(draft =&gt; {</span><br><span class="line">      draft.artwork.city = e.target.value;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleImageChange(e) {</span><br><span class="line">    updatePerson(draft =&gt; {</span><br><span class="line">      draft.artwork.image = e.target.value;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.name}</span><br><span class="line">          onChange={handleNameChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Title:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.artwork.title}</span><br><span class="line">          onChange={handleTitleChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        City:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.artwork.city}</span><br><span class="line">          onChange={handleCityChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Image:</span><br><span class="line">        &lt;input</span><br><span class="line">          value={person.artwork.image}</span><br><span class="line">          onChange={handleImageChange}</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;i&gt;{person.artwork.title}&lt;/i&gt;</span><br><span class="line">        {' by '}</span><br><span class="line">        {person.name}</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        (located in {person.artwork.city})</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;img </span><br><span class="line">        src={person.artwork.image} </span><br><span class="line">        alt={person.artwork.title}</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这样，事件处理函数就变得简洁了。可以随意在一个组件中同时使用 <code>useState</code> 和 <code>useImmer</code>。如果你、想要写出更简洁的更新处理函数，Immer 会是一个不错的选择，尤其是当你的 state 中有嵌套，并且复制对象会带来重复的代码时。</p>
<h2 id="更新state中的数组"><a href="#更新state中的数组" class="headerlink" title="更新state中的数组"></a>更新state中的数组</h2><p>数组也是另外一种可以存储在state中的JavaScript对象，数组本身是可变的，但是应该视为不可变。同对象一样，如果想要更新存储于state中的数组时，需要创建一个新的数组（或者创意一份已有数组的拷贝值），并使用新数组设置state。</p>
<h3 id="在没有mutation的前提下更新数组"><a href="#在没有mutation的前提下更新数组" class="headerlink" title="在没有mutation的前提下更新数组"></a>在没有mutation的前提下更新数组</h3><p>在JavaScript中，数组是另一种对象。<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-objects-in-state">同对象一样</a>，<strong>需要将React state中的数值是为只读的。</strong>这意味着不应该使用类似于 <code>arr[0] = 'bird'</code>这样的方式来修改数组中的元素，也不<strong>应该使用会直接修改原数组的方法</strong>，例如<code>push()</code>和<code>pop()</code>。</p>
<p>相反，在需要更新一个数组时，需要将一个<strong>新的数组</strong>传入state中的setting方法中。为此我们可以通过 <code>filter()</code> 和 <code>map()</code> 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。</p>
<p>以下是常见数组操作的api。当操作React state中的数组时，应该避免左列的方法，而选择右列的方法。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">避免使用 <br>(会改变原始数组)</th>
<th align="center"><strong>推荐使用<br> (会返回一个新数组）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td align="center"><code>push</code>，<code>unshift</code></td>
<td align="center"><code>concat</code>，<code>[...arr]</code> 展开语法（<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-arrays-in-state#adding-to-an-array">例子</a>）</td>
</tr>
<tr>
<td>删除元素</td>
<td align="center"><code>pop</code>，<code>shift</code>，<code>splice</code></td>
<td align="center"><code>filter</code>，<code>slice</code>（<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-arrays-in-state#removing-from-an-array">例子</a>）</td>
</tr>
<tr>
<td>替换元素</td>
<td align="center"><code>splice</code>，<code>arr[i] = ...</code> 赋值</td>
<td align="center"><code>map</code>（<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-arrays-in-state#replacing-items-in-an-array">例子</a>）</td>
</tr>
<tr>
<td>排序</td>
<td align="center"><code>reverse</code>，<code>sort</code></td>
<td align="center">先将数组复制一份（<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-arrays-in-state#making-other-changes-to-an-array">例子</a>）</td>
</tr>
</tbody></table>
<p>或者，可以使用<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-arrays-in-state#write-concise-update-logic-with-immer">使用 Immer</a> ，这样就可以使用表格中的所有方法了。</p>
<p>注意：</p>
<p><code>slice</code>和<code>splice</code>方法作用不同</p>
<ul>
<li><code>slice</code>可以拷贝数组或者数组的一部分。</li>
<li><code>splice</code><strong>会直接修改</strong>原始数组（插入或者删除元素）</li>
</ul>
<h3 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h3><p>如果利用<code>push()</code>会直接修改原始数组，而这个不是我们期望的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let nextId = 0;</span><br><span class="line"></span><br><span class="line">export default function List() {</span><br><span class="line">  const [name, setName] = useState('');</span><br><span class="line">  const [artists, setArtists] = useState([]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;振奋人心的雕塑家们：&lt;/h1&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        value={name}</span><br><span class="line">        onChange={e =&gt; setName(e.target.value)}</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; {</span><br><span class="line">        artists.push({</span><br><span class="line">          id: nextId++,</span><br><span class="line">          name: name,</span><br><span class="line">        });</span><br><span class="line">      }}&gt;添加&lt;/button&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        {artists.map(artist =&gt; (</span><br><span class="line">          &lt;li key={artist.id}&gt;{artist.name}&lt;/li&gt;</span><br><span class="line">        ))}</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>以上例子中，我们应该创建一个<strong>新的数组</strong>，其包含了原始数组中的所有元素<strong>以及</strong>一个在末尾添加的新元素。可以有很多种办法实现。最简单的一种就是使用 <code>...</code> <a target="_blank" rel="noopener" href="https://react.docschina.org/a-javascript-refresher#array-spread">数组展开</a> 语法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setArtists( // 替换 state</span><br><span class="line">  [ // 是通过传入一个新数组实现的</span><br><span class="line">    ...artists, // 新数组包含原数组的所有元素</span><br><span class="line">    { id: nextId++, name: name } // 并在末尾添加了一个新的元素</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>还可以通过展开运算符将新添的元素放在原始的<code>...artists</code>之前：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setArtists([</span><br><span class="line">  { id: nextId++, name: name },</span><br><span class="line">  ...artists // 将原数组中的元素放在末尾</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure>

<p>这样看来，展开运算符就可以完成<code>push()</code>和<code>unshift()</code>的效果。</p>
<h3 id="从数组中删除元素"><a href="#从数组中删除元素" class="headerlink" title="从数组中删除元素"></a>从数组中删除元素</h3><p>从数组中删除元素最简单的方法就是将它<strong>过滤出去</strong>。可以通过<code>filter</code>方法实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let initialArtists = [</span><br><span class="line">  { id: 0, name: 'Marta Colvin Andrade' },</span><br><span class="line">  { id: 1, name: 'Lamidi Olonade Fakeye'},</span><br><span class="line">  { id: 2, name: 'Louise Nevelson'},</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function List() {</span><br><span class="line">  const [artists, setArtists] = useState(</span><br><span class="line">    initialArtists</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;振奋人心的雕塑家们：&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        {artists.map(artist =&gt; (</span><br><span class="line">          &lt;li key={artist.id}&gt;</span><br><span class="line">            {artist.name}{' '}</span><br><span class="line">            &lt;button onClick={() =&gt; {</span><br><span class="line">              setArtists(</span><br><span class="line">                artists.filter(a =&gt;</span><br><span class="line">                  a.id !== artist.id</span><br><span class="line">                )</span><br><span class="line">              );</span><br><span class="line">            }}&gt;</span><br><span class="line">              删除</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))}</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>点击“删除”按钮几次，每次都会触发</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setArtists(</span><br><span class="line">  artists.filter(a =&gt; a.id !== artist.id)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>与<code>push()</code>不同的是这里的<code>filter()</code>表示<strong>“创建一个新的数组”</strong>。也就是生成了新的数组，通过state更新，并触发渲染。但是<code>filter()</code>不会改变原数组。</p>
<h3 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h3><p>如果想改变数组中的某些或者所有元素。使用<code>map()</code>创建一个<strong>新数组</strong>。传入的<code>map</code>函数据定了根据每个元素或者索引（或二者都作为条件）对元素进行处理。</p>
<p>在下面的例子中，一个数组记录了两个圆形和一个正方形的坐标。当你点击按钮时，仅有两个圆形会向下移动 100 像素。这是通过使用 <code>map()</code> 生成一个新数组实现的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let initialShapes = [</span><br><span class="line">  { id: 0, type: 'circle', x: 50, y: 100 },</span><br><span class="line">  { id: 1, type: 'square', x: 150, y: 100 },</span><br><span class="line">  { id: 2, type: 'circle', x: 250, y: 100 },</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function ShapeEditor() {</span><br><span class="line">  const [shapes, setShapes] = useState(</span><br><span class="line">    initialShapes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleClick() {</span><br><span class="line">    const nextShapes = shapes.map(shape =&gt; {</span><br><span class="line">      if (shape.type === 'square') {</span><br><span class="line">        // 不作改变</span><br><span class="line">        return shape;</span><br><span class="line">      } else {</span><br><span class="line">        // 返回一个新的圆形，位置在下方 50px 处</span><br><span class="line">        return {</span><br><span class="line">          ...shape,</span><br><span class="line">          y: shape.y + 50,</span><br><span class="line">        };</span><br><span class="line">      }</span><br><span class="line">    });</span><br><span class="line">    // 使用新的数组进行重渲染</span><br><span class="line">    setShapes(nextShapes);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick={handleClick}&gt;</span><br><span class="line">        所有圆形向下移动！</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      {shapes.map(shape =&gt; (</span><br><span class="line">        &lt;div</span><br><span class="line">          key={shape.id}</span><br><span class="line">          style={{</span><br><span class="line">          background: 'purple',</span><br><span class="line">          position: 'absolute',</span><br><span class="line">          left: shape.x,</span><br><span class="line">          top: shape.y,</span><br><span class="line">          borderRadius:</span><br><span class="line">            shape.type === 'circle'</span><br><span class="line">              ? '50%' : '',</span><br><span class="line">          width: 20,</span><br><span class="line">          height: 20,</span><br><span class="line">        }} /&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="替换数组中的元素"><a href="#替换数组中的元素" class="headerlink" title="替换数组中的元素"></a>替换数组中的元素</h3><p>如果存在替换数组中或者多个元素需求的话。类似 <code>arr[0] = 'bird'</code> 这样的赋值语句会直接修改原始数组，所以在这种情况下，我们也应该使用 <code>map</code>。</p>
<p>要替换一个元素，请使用 <code>map</code> 创建一个新数组。在你的 <code>map</code> 回调里，第二个参数是元素的索引。使用索引来判断最终是返回原始的元素（即回调的第一个参数）还是替换成其他值：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let initialCounters = [</span><br><span class="line">  0, 0, 0</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function CounterList() {</span><br><span class="line">  const [counters, setCounters] = useState(</span><br><span class="line">    initialCounters</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleIncrementClick(index) {</span><br><span class="line">    const nextCounters = counters.map((c, i) =&gt; {</span><br><span class="line">      if (i === index) {</span><br><span class="line">        // 递增被点击的计数器数值</span><br><span class="line">        return c + 1;</span><br><span class="line">      } else {</span><br><span class="line">        // 其余部分不发生变化</span><br><span class="line">        return c;</span><br><span class="line">      }</span><br><span class="line">    });</span><br><span class="line">    setCounters(nextCounters);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      {counters.map((counter, i) =&gt; (</span><br><span class="line">        &lt;li key={i}&gt;</span><br><span class="line">          {counter}</span><br><span class="line">          &lt;button onClick={() =&gt; {</span><br><span class="line">            handleIncrementClick(i);</span><br><span class="line">          }}&gt;+1&lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="向数组中插入元素"><a href="#向数组中插入元素" class="headerlink" title="向数组中插入元素"></a>向数组中插入元素</h3><p>有时候也会存在向数组特定位置插入一个元素，这个位置既不在开头，又不在末尾。这时候就可以使用数组展开运算符 <code>...</code> 和 <code>slice()</code> 方法一起使用。<code>slice()</code> 方法可以从数组中切出“一片”。为了将元素插入数组，需要先展开原数组在插入点之前的切片，然后插入新元素，最后展开原数组中剩下的部分。</p>
<p>下面的例子中，插入按钮总是会将元素插入到数组中索引为 <code>1</code> 的位置。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialArtists = [</span><br><span class="line">  { id: 0, name: 'Marta Colvin Andrade' },</span><br><span class="line">  { id: 1, name: 'Lamidi Olonade Fakeye'},</span><br><span class="line">  { id: 2, name: 'Louise Nevelson'},</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function List() {</span><br><span class="line">  const [name, setName] = useState('');</span><br><span class="line">  const [artists, setArtists] = useState(</span><br><span class="line">    initialArtists</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleClick() {</span><br><span class="line">    const insertAt = 1; // 可能是任何索引</span><br><span class="line">    const nextArtists = [</span><br><span class="line">      // 插入点之前的元素：</span><br><span class="line">      ...artists.slice(0, insertAt),</span><br><span class="line">      // 新的元素：</span><br><span class="line">      { id: nextId++, name: name },</span><br><span class="line">      // 插入点之后的元素：</span><br><span class="line">      ...artists.slice(insertAt)</span><br><span class="line">    ];</span><br><span class="line">    setArtists(nextArtists);</span><br><span class="line">    setName('');</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;振奋人心的雕塑家们：&lt;/h1&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        value={name}</span><br><span class="line">        onChange={e =&gt; setName(e.target.value)}</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button onClick={handleClick}&gt;</span><br><span class="line">        插入</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        {artists.map(artist =&gt; (</span><br><span class="line">          &lt;li key={artist.id}&gt;{artist.name}&lt;/li&gt;</span><br><span class="line">        ))}</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="其他改变数组情况"><a href="#其他改变数组情况" class="headerlink" title="其他改变数组情况"></a>其他改变数组情况</h3><p>还会存在，依靠展开运算符和<code>map()</code>或者<code>filter()</code>等不回直接修改原值的方法无法做到。例如：翻转数组、数组排序。而因为JavaScript中的 <code>reverse()</code> 和 <code>sort()</code> 方法会改变原数组，所以你无法直接使用它们。</p>
<p><strong>然而我们可以先拷贝这个数组，在改变这个拷贝后的值</strong></p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialList = [</span><br><span class="line">  { id: 0, title: 'Big Bellies' },</span><br><span class="line">  { id: 1, title: 'Lunar Landscape' },</span><br><span class="line">  { id: 2, title: 'Terracotta Army' },</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function List() {</span><br><span class="line">  const [list, setList] = useState(initialList);</span><br><span class="line"></span><br><span class="line">  function handleClick() {</span><br><span class="line">    const nextList = [...list];</span><br><span class="line">    nextList.reverse();</span><br><span class="line">    setList(nextList);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick={handleClick}&gt;</span><br><span class="line">        翻转</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        {list.map(artwork =&gt; (</span><br><span class="line">          &lt;li key={artwork.id}&gt;{artwork.title}&lt;/li&gt;</span><br><span class="line">        ))}</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在这里，我们现使用展开运算符进行了原数组的拷贝。有了这个拷贝值，就可以直接通过<code>nextList.reverse()</code> 或 <code>nextList.sort()</code> 这样直接修改原数组的方法。甚至可以通过 <code>nextList[0] = "something"</code> 这样的方式对数组中的特定元素进行赋值。</p>
<p><strong>即使拷贝了数组，还是不能直接修改其内部的元素</strong>。这是因为数组的拷贝是浅拷贝–新的数组中依然保留了与原始数组相同的元素。</p>
<p>因此，修改了拷贝数组内部的某个对象，其实就是直接在修改当前的state。如下面的代码；</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const nextList = [...list];</span><br><span class="line">nextList[0].seen = true; // 问题：直接修改了 list[0] 的值</span><br><span class="line">setList(nextList);</span><br></pre></td></tr></tbody></table></figure>

<p>虽然 <code>nextList</code> 和 <code>list</code> 是两个不同的数组，**<code>nextList[0]</code> 和 <code>list[0]</code> 却指向了同一个对象**。因此，通过改变 <code>nextList[0].seen</code>，<code>list[0].seen</code> 的值也被改变了。这是一种 state 的 mutation 操作，你应该避免这么做！可以用类似于 <a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-objects-in-state#updating-a-nested-object">更新嵌套的 JavaScript 对象</a> 的方式解决这个问题——拷贝想要修改的特定元素，而不是直接修改它。下面是具体的操作。</p>
<h3 id="更新数组内部的对象"><a href="#更新数组内部的对象" class="headerlink" title="更新数组内部的对象"></a>更新数组内部的对象</h3><p><strong>对象并不是真的位于数组“内部”</strong>。可能在代码层面上来看像是在“内部”，但其实际数组中的每个对象都是这个数组“指向”的一个存储其他位置的值。所以在处理<code>list[0]</code>嵌套字段的时候需要格外小心，其他元素的值kennel也指向了数组的同一个元素。</p>
<p><strong>当更新一个嵌套的 state 时，需要从想要更新的地方创建拷贝值，一直这样，直到顶层。</strong></p>
<p>在下面的例子中，两个不同的艺术品清单有着相同的初始 state。他们本应该互不影响，但是因为一次 mutation，他们的 state 被意外地共享了，勾选一个清单中的事项会影响另外一个清单：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line"></span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialList = [</span><br><span class="line">  { id: 0, title: 'Big Bellies', seen: false },</span><br><span class="line">  { id: 1, title: 'Lunar Landscape', seen: false },</span><br><span class="line">  { id: 2, title: 'Terracotta Army', seen: true },</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function BucketList() {</span><br><span class="line">  const [myList, setMyList] = useState(initialList);</span><br><span class="line">  const [yourList, setYourList] = useState(</span><br><span class="line">    initialList</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleToggleMyList(artworkId, nextSeen) {</span><br><span class="line">    const myNextList = [...myList];</span><br><span class="line">    const artwork = myNextList.find(</span><br><span class="line">      a =&gt; a.id === artworkId</span><br><span class="line">    );</span><br><span class="line">    artwork.seen = nextSeen;</span><br><span class="line">    setMyList(myNextList);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleToggleYourList(artworkId, nextSeen) {</span><br><span class="line">    const yourNextList = [...yourList];</span><br><span class="line">    const artwork = yourNextList.find(</span><br><span class="line">      a =&gt; a.id === artworkId</span><br><span class="line">    );</span><br><span class="line">    artwork.seen = nextSeen;</span><br><span class="line">    setYourList(yourNextList);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;艺术愿望清单&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt;</span><br><span class="line">      &lt;ItemList</span><br><span class="line">        artworks={myList}</span><br><span class="line">        onToggle={handleToggleMyList} /&gt;</span><br><span class="line">      &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt;</span><br><span class="line">      &lt;ItemList</span><br><span class="line">        artworks={yourList}</span><br><span class="line">        onToggle={handleToggleYourList} /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function ItemList({ artworks, onToggle }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      {artworks.map(artwork =&gt; (</span><br><span class="line">        &lt;li key={artwork.id}&gt;</span><br><span class="line">          &lt;label&gt;</span><br><span class="line">            &lt;input</span><br><span class="line">              type="checkbox"</span><br><span class="line">              checked={artwork.seen}</span><br><span class="line">              onChange={e =&gt; {</span><br><span class="line">                onToggle(</span><br><span class="line">                  artwork.id,</span><br><span class="line">                  e.target.checked</span><br><span class="line">                );</span><br><span class="line">              }}</span><br><span class="line">            /&gt;</span><br><span class="line">            {artwork.title}</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>其实问题就是出现在</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myNextList = [...myList];</span><br><span class="line">const artwork = myNextList.find(a =&gt; a.id === artworkId);</span><br><span class="line">artwork.seen = nextSeen; // 问题：直接修改了已有的元素</span><br><span class="line">setMyList(myNextList);</span><br></pre></td></tr></tbody></table></figure>

<p>虽然复制出来了新的数组<code>myNextList</code>,但是其<strong>内部的元素本身</strong>与原数组<code>myList</code>是相同的。因此修改了新数组<code>myNextList</code>中 <code>artwork.seen</code>，其实是在修改<strong>原始的</strong> artwork 对象。而这个对象也在<code>youList</code>中使用，这样就导致存在问题。</p>
<p><strong>其实可以使用<code>map()</code>在没有mutation的前提下将一个旧的元素替换成新的更新版本。</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setMyList(myList.map(artwork =&gt; {</span><br><span class="line">  if (artwork.id === artworkId) {</span><br><span class="line">    // 创建包含变更的*新*对象</span><br><span class="line">    return { ...artwork, seen: nextSeen };</span><br><span class="line">  } else {</span><br><span class="line">    // 没有变更</span><br><span class="line">    return artwork;</span><br><span class="line">  }</span><br><span class="line">}));</span><br></pre></td></tr></tbody></table></figure>

<p>此处的 <code>...</code> 是一个对象展开语法，被用来<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax">创建一个对象的拷贝</a>.</p>
<p><strong>通常来讲，我们应该只修改刚刚创建的对象。</strong>如果正在插入一个<strong>新</strong>的元素，可以修改它，但是如果想改变state中已经存在的东西，就需要先拷贝一份了。</p>
<h3 id="使用Immer编写简洁的更新逻辑"><a href="#使用Immer编写简洁的更新逻辑" class="headerlink" title="使用Immer编写简洁的更新逻辑"></a>使用Immer编写简洁的更新逻辑</h3><p>在没有 mutation 的前提下更新嵌套数组可能会变得有点重复。<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/updating-objects-in-state#write-concise-update-logic-with-immer">就像对对象一样</a>:</p>
<ul>
<li>通常情况下，我们应该不需要更新处于非常深层级的 state 。如果有此类需求，或许需要<a target="_blank" rel="noopener" href="https://react.docschina.org/learn/choosing-the-state-structure#avoid-deeply-nested-state">调整一下数据的结构</a>，让数据变得扁平一些。</li>
<li>如果不想改变 state 的数据结构，使用 <a target="_blank" rel="noopener" href="https://github.com/immerjs/use-immer">Immer</a> ，它可以让我们继续使用方便的，但会直接修改原值的语法，并负责生成拷贝值。</li>
</ul>
<p>下面是，使用Immer改写的例子</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import { useState } from 'react';</span><br><span class="line">import { useImmer } from 'use-immer';</span><br><span class="line"></span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialList = [</span><br><span class="line">  { id: 0, title: 'Big Bellies', seen: false },</span><br><span class="line">  { id: 1, title: 'Lunar Landscape', seen: false },</span><br><span class="line">  { id: 2, title: 'Terracotta Army', seen: true },</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function BucketList() {</span><br><span class="line">  const [myList, updateMyList] = useImmer(</span><br><span class="line">    initialList</span><br><span class="line">  );</span><br><span class="line">  const [yourList, updateYourList] = useImmer(</span><br><span class="line">    initialList</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleToggleMyList(id, nextSeen) {</span><br><span class="line">    updateMyList(draft =&gt; {</span><br><span class="line">      const artwork = draft.find(a =&gt;</span><br><span class="line">        a.id === id</span><br><span class="line">      );</span><br><span class="line">      artwork.seen = nextSeen;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  function handleToggleYourList(artworkId, nextSeen) {</span><br><span class="line">    updateYourList(draft =&gt; {</span><br><span class="line">      const artwork = draft.find(a =&gt;</span><br><span class="line">        a.id === artworkId</span><br><span class="line">      );</span><br><span class="line">      artwork.seen = nextSeen;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;艺术愿望清单&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;我想看的艺术清单：&lt;/h2&gt;</span><br><span class="line">      &lt;ItemList</span><br><span class="line">        artworks={myList}</span><br><span class="line">        onToggle={handleToggleMyList} /&gt;</span><br><span class="line">      &lt;h2&gt;你想看的艺术清单：&lt;/h2&gt;</span><br><span class="line">      &lt;ItemList</span><br><span class="line">        artworks={yourList}</span><br><span class="line">        onToggle={handleToggleYourList} /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function ItemList({ artworks, onToggle }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      {artworks.map(artwork =&gt; (</span><br><span class="line">        &lt;li key={artwork.id}&gt;</span><br><span class="line">          &lt;label&gt;</span><br><span class="line">            &lt;input</span><br><span class="line">              type="checkbox"</span><br><span class="line">              checked={artwork.seen}</span><br><span class="line">              onChange={e =&gt; {</span><br><span class="line">                onToggle(</span><br><span class="line">                  artwork.id,</span><br><span class="line">                  e.target.checked</span><br><span class="line">                );</span><br><span class="line">              }}</span><br><span class="line">            /&gt;</span><br><span class="line">            {artwork.title}</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>请注意当使用 Immer 时，<strong>类似 <code>artwork.seen = nextSeen</code> 这种会产生 mutation 的语法不会再有任何问题了：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">updateMyTodos(draft =&gt; {</span><br><span class="line">  const artwork = draft.find(a =&gt; a.id === artworkId);</span><br><span class="line">  artwork.seen = nextSeen;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为并不是在修改原始的state，而是在修改Immer提供的特殊<code>draft</code>对象。同理，也可以为<code>draft</code>的内容使用<code>push()``pop()</code>这些会直接修改原值的方法。</p>
<p>幕后，Immer 总是会根据你对 <code>draft</code> 的修改来从头开始构建下一个 state。这使得你的事件处理程序非常的简洁，同时也不会直接修改 state。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/react/" rel="tag"># react</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/31/%20React-%E6%8F%8F%E8%BF%B0UI/" rel="prev" title="React入门之描述UI">
                  <i class="fa fa-chevron-left"></i> React入门之描述UI
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ayozooZ</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">38k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:05</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
